module.exports = {
  addPopScopes: function (arg0_pop_scope, arg1_pop_scope) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var ot_pop_scope = arg1_pop_scope;

    //Declare local instance variables
    var all_ot_pop_scope_keys = Object.keys(ot_pop_scope);
    var all_ot_pop_scope_tags = Object.keys(ot_pop_scope.tags);
    var sum_size = pop_scope.size + ot_pop_scope.size;

    var from_scalar = ot_pop_scope.size/sum_size;
    var to_scalar = pop_scope.size/sum_size;

    //Weighted average top-level attributes. Exclude wealth/size
    for (var i = 0; i < all_ot_pop_scope_keys.length; i++)
      if (!reserved.pop_scope_sum_keys.includes(all_ot_pop_scope_keys)) {
        var local_value = pop_scope[all_ot_pop_scope_keys[i]];
        var local_ot_value = ot_pop_scope[all_ot_pop_scope_keys[i]];

        if (typeof local_ot_value == "number")
          if (pop_scope[all_ot_pop_scope_keys[i]]) {
            //Weight by size
            var from_factor = local_value*from_scalar;
            var to_factor = local_ot_value*to_scalar;

            pop_scope[all_ot_pop_scope_keys[i]] = Math.ceil((from_factor + to_factor)/2);
          } else {
            //Not there, set to pop_scope
            pop_scope[all_ot_pop_scope_keys[i]] = local_value;
          }
      }

    //Add wealth, size
    pop_scope.size = sum_size;
    pop_scope.wealth = pop_scope.wealth + ot_pop_scope.wealth;

    //Merge tags
    pop_scope.tags = mergeObjects(pop_scope, ot_pop_scope);

    //Return statement
    return pop_scope;
  },

  /*
    createPops() - Generates a certain number of pops for a given province with standard rolling. [WIP] - Add ability for pops to be generated by scope later
    options: {
      new_turn: true, - Optional. Whether pops are being created on a new turn. False by default.

      age: {
        min: 0,
        max: 120,
        mean: 60 - Optional. Midpoint by default
      },
      age: 45, - Exclusive with the above arguments
      culture: ["09418904328"], - Optional. The IDs of the culture to generate pops for. Undefined by default. Can also be object of percentage values: { "09418904328": 1.00  }
      education_level: { - Optional. Undefined by default
        min: 0,
        max: 1,
        mean: 0.50 - Optional. Midpoint by default
      },
      tags: {}, - Adds certain tags to the end province. Used typically for transferring pops
      type: "all"/["workers", "soldiers"] - Chooses the types of pops to generate
      amount: 100000 - How many pops should be generated in the given province
    }
  */
  createPops: function (arg0_province, arg1_options) {
    //Convert from parameters
    var province_obj = getProvince(arg0_province);
    var options = arg1_options;

    //Initialise default options values
    options.type = (options.type) ? ["all"] : getList(options.type);

    //Declare local instance variables
    var all_pops = (options.type.includes("all")) ?
      Object.keys(config.pops) :
      options.type;
    var old_population = (province_obj.pops) ? JSON.parse(JSON.stringify(province_obj.pops)) : {};
    var relevant_pops = module.exports.getRelevantPops(user_id); //Returns pop key list
    var usr = (province_obj) ? main.users[province_obj.controller] : undefined;

    //Regular error trapping
    try {
      //Remove old user population so that it can be 'reset' to accomodate the new one
      usr.population -= province_obj.population;

      //Generate pops similar to settle_province.js
      var population_cache = options.amount;
      if (!province_obj.pops) province_obj.pops = {};

      //Generate all pops through chance
      var pop_chances = {}; //Standardise sum to 1

      for (var i = 0; i < relevant_pops.length; i++) {
        var local_pop = config.pops[relevant_pops[i]];

        if (local_pop.chance) {
          var random_percentage = randomNumber((local_pop.chance*100)/2, (local_pop.chance*100)*2, true);

          pop_chances[relevant_pops[i]] = random_percentage;
        }
      }

      log.debug(`Pop Chances: `, pop_chances);

      pop_chances = standardisePercentage(pop_chances);
      var all_pop_chances = Object.keys(pop_chances);
      var culture_percentages = getProvinceCulture(province_obj.id);

      var all_cultures = Object.keys(culture_percentages);

      //Partition pops in pop_chances
      for (var i = 0; i < all_pop_chances.length; i++) {
        var local_chance = pop_chances[all_pop_chances[i]];
        var population_change = parseInt(options.amount*local_chance);

        //Undefined pops save space in the DB
        modifyValue(province_obj.pops, all_pop_chances[i], population_change);

        //Distribute age
        if (!options.age) options.age = 0; //It needs to be something
        if (options.age != undefined)
          if (typeof options.age == "object") {
            var current_year = main.date.year;
            var max = returnSafeNumber(options.age.max, config.defines.economy.old_age_hard_upper_bound);
            var min = returnSafeNumber(options.age.min, 0);

            var domain = Math.abs(max - min);

            if (!options.education_level.mean) {
              //If there's no mean, assume equal distribtuion
              var local_percentage = 1/domain;

              for (var x = 0; x < max; x++)
                modifyValue(province_obj.pops, `b_${Math.floor(current_year + 1)}`, Math.floor(population_change*local_percentage));
            } else {
              var age_distribution = pearsonVIIDistribution(domain, options.age.mean, min, max);
              var all_age_distribution_keys = Object.keys(age_distribution);

              for (var x = 0; x < all_age_distribution_keys.length; x++) {
                var local_percentage = age_distribution[all_age_distribution_keys[x]];

                modifyValue(province_obj.pops, `b_${parseInt(all_age_distribution_keys[x]) + min}`, Math.floor(population_change*local_percentage));
              }
            }
          } else {
            var turn_years = Math.floor(getTurnHours()/(365*24));

            for (var x = 0; x < turn_years; x++) {
              var local_percentage = 1/turn_years;

              modifyValue(province_obj.pops, `b_${main.date.year - turn_years + x}`, Math.floor(population_change*local_percentage));
            }
          }

        //Distribute cultures proportionally
        if (!options.culture) {
          for (var x = 0; x < all_cultures.length; x++)
            modifyValue(province_obj.pops, `culture-${all_cultures[x]}`, population_change*Math.floor(culture_percentages[all_cultures[x]]));
        } else {
          if (typeof options.culture != "object") {
            var adjusted_percentages = {};
            var culture_list = getList(options.culture);
            var percentage_total = 0;

            for (var x = 0; x < culture_list.length; x++)
              adjusted_percentages[culture_list[x]] = returnSafeNumber(culture_percentages[culture_list[x]]);
            adjusted_percentages = standardisePercentage(adjusted_percentages);

            for (var x = 0; x < culture_list.length; x++)
              modifyValue(province_obj.pops, `culture-${culture_list[x]}`, population_change*Math.floor(culture_percentages[all_cultures[x]]));
          } else {
            var adjusted_percentages = standardisePercentage(options.culture);
            var all_specified_cultures = Object.keys(adjusted_percentages);

            for (var x = 0; x < all_specified_cultures.length; x++)
              modifyValue(province_obj.pops, `culture-${all_specified_cultures[x]}`, population_change*Math.floor(adjusted_percentages[all_specified_cultures[x]]));
          }
        }

        //Distribute education level if specified
        if (options.education_level) { //0 education by default - newborns can't read!
          var max = returnSafeNumber(options.education_level.max, 1);
          var min = returnSafeNumber(options.education_level.min, 0);

          if (!options.education_level.mean) {
            //If there's no mean, assume equal distribution
            var local_percentage = 1/Math.abs(max - min);

            for (var x = min; x < max; x++)
              modifyValue(province_obj.pops, `el_${Math.floor(x*100)}`, population_change*local_percentage);
          } else {
            var education_distribution = pearsonVIIDistribution(100, options.education_level.mean, min, max, {
              key_name: "el"
            });
            var all_education_distribution_keys = Object.keys(education_distribution);

            for (var x = 0; x < all_education_distribution_keys.length; x++) {
              var local_percentage = education_distribution[all_education_distribution_keys[x]];

              modifyValue(province_obj.pops, all_education_distribution_keys[x], population_change*local_percentage);
            }
          }
        }
      }


      //Calculate new total population of province and add it to user tracker variables
      {
        var all_local_pops = Object.keys(province_obj.pops);
        var total_population = 0;

        for (var i = 0; i < all_local_pops.length; i++)
          if (config.pops[all_local_pops[i]]) {
            var local_value = province_obj.pops[all_local_pops[i]];

            usr.pops[all_local_pops[i]] += local_value;
            total_population += local_value;
          }
      }

      //Process tags
      if (options.tags) {
        var all_tags = Object.keys(options.tags);

        for (var i = 0; i < all_tags.length; i++)
          modifyValue(province_obj.pops, all_tags[i], options.tags[all_tags[i]]);
      }

      //Add total_population back to usr.population and province tracker
      province_obj.pops.population = total_population;
      usr.population += total_population;
    } catch (e) {
      log.error(`createPops() ran into an error: ${e}.`);
    }
  },

  /*
    getActualPopFulfilment() - Gets actual pop fulfilment for the stated scope as a weighted average by wealth pool.
    options: {
      province_id: "4709", - The province ID which to target
      pop_type: "soldiers", - The pop type for which to fetch fulfilment/variety for

      good_scope: "staple_goods"/"chocolate" - Optional. Defaults to all. Individual goods are calculated with received_goods per category per wealth pool.
    }
  */
  getActualPopFulfilment: function (arg0_options) { //[WIP] - Add subsidy and subsistence calculations later
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var fulfilment = 0;
    var province_id = options.province_id;
    var province_obj = main.provinces[province_id];
    var total_fulfilment = 0;
    var total_variety = 0;
    var variety = 0;

    if (province_obj.pops) {
      var all_pop_keys = Object.keys(province_obj.pops);
      var is_good = (lookup.all_goods[options.good_scope]);
      var local_population = returnSafeNumber(province_obj.pops[options.pop_type]);

      for (var i = 0; i < all_pop_keys.length; i++)
        if (all_pop_keys[i].startsWith("wealth-")) {
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
          var split_key = all_pop_keys[i].split("-");

          var pop_type = split_key[2];

          if (pop_type == options.pop_type) {
            var has_needs = false;
            var pop_obj = config.pops[pop_type];
            var total_goods = 0;
            var total_subgoods_fulfilled = 0;

            if (pop_obj.per_100k)
              if (pop_obj.per_100k.needs) has_needs = true;

            if (has_needs) {
              if (is_good) {
                var local_subgoods = lookup.all_subgoods[options.good_scope];
                var per_100k_need = 0;

                for (var x = 0; x < pop_obj.buy_order.length; x++) {
                  var local_needs_category = pop_obj.per_100k.needs[pop_obj.buy_order[x]];
                  var local_received_goods = local_wealth_pool.received_goods[pop_obj.buy_order[x]];

                  for (var y = 0; y < local_subgoods.length; y++)
                    if (local_received_goods[local_subgoods[y]]) {
                      var local_value = local_received_goods[local_subgoods[y]];

                      total_goods += returnSafeNumber(local_value);
                      if (local_value > 0) total_subgoods_fulfilled++;

                      per_100k_need += returnSafeNumber(local_needs_category[local_subgoods[y]]);
                    }
                }

                var actual_need = per_100k_need*(local_wealth_pool.size/100000);

                //Set total_fulfilment; total_variety
                total_fulfilment += Math.min(local_wealth_pool.size*(total_goods/actual_need), local_wealth_pool.size);
                total_variety += Math.min(local_wealth_pool.size*(total_subgoods_fulfilled/local_subgoods.length), local_wealth_pool.size);
              } else if (pop_obj.buy_order.includes(options.good_scope)) {
                total_fulfilment += local_wealth_pool.size*returnSafeNumber(local_wealth_pool[`${options.good_scope}-fulfilment`]);
                total_variety += local_wealth_pool.size*returnSafeNumber(local_wealth_pool[`${options.good_scope}-variety`]);
              } else {
                //All handler
                total_fulfilment += local_wealth_pool.size*returnSafeNumber(local_wealth_pool.fulfilment);
                total_variety += local_wealth_pool.size*returnSafeNumber(local_wealth_pool.variety);
              }
            } else {
              total_fulfilment += local_wealth_pool.size*config.defines.economy.default_fulfilment;
              total_variety += local_wealth_pool.size*config.defines.economy.default_variety;
            }
          }
        }

      //Set fulfilment; variety
      fulfilment = total_fulfilment/local_population;
      variety = total_variety/local_population;

      //Return statement
      return {
        fulfilment: fulfilment,
        variety: variety
      };
    }
  },

  //getAllPopGoods() - Returns an array of all good keys demanded or produced by pop types w/ more than 0 people
  getAllPopGoods: function (arg0_user) { //[WIP] - Finish function body
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_goods = [];
    var relevant_pops = module.exports.getRelevantPops(user_id);
    var usr = main.users[actual_id];

    //Iterate over relevant_pops and recursively parse objects and subobjects for goods
    for (var i = 0; i < relevant_pops.length; i++) {
      var local_pop = config.pops[relevant_pops[i]];

      //max_modifier_limit
      if (local_pop.max_modifier_limit) {
        var max_modifier_limit_keys = Object.keys(local_pop.max_modifier_limit);

        for (var x = 0; x < max_modifier_limit_keys.length; x++)
          if (!all_pop_goods.includes(max_modifier_limit_keys[x]))
            if (lookup.all_goods[max_modifier_limit_keys[x]])
              all_pop_goods.push(max_modifier_limit_keys[x]);
      }

      //per_100k handler
      if (local_pop.per_100k) {
        var all_relevant_subgoods = getAllSubgoods(local_pop.per_100k);

        for (var x = 0; x < all_relevant_subgoods.length; x++)
          if (!all_pop_goods.includes(all_relevant_subgoods[x]))
            all_pop_goods.push(all_relevant_subgoods[x]);
      }
    }

    //Return statement
    return all_pop_goods;
  },

  //getAllPopNeeds() - Returns an object of all flattened pop needs
  getAllPopNeeds: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var all_pop_needs_obj = {};

    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs)
          all_pop_needs_obj[all_pops[i]] = flattenObject(local_pop.per_100k.needs);
    }

    return all_pop_needs_obj;
  },

  //getAllPopNeedCategories() - Returns a list of pop need categories such as luxury_goods, staple_goods, etc.
  getAllPopNeedCategories: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var pop_categories = [];

    //Iterate over all_pops
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs) {
          var all_local_needs_categories = Object.keys(local_pop.per_100k.needs);

          for (var x = 0; x < all_local_needs_categories.length; x++)
            if (!pop_categories.includes(all_local_needs_categories[x]))
              pop_categories.push(all_local_needs_categories[x]);
        }
    }

    //Return statement
    return pop_categories;
  },

  getCityPopGrowth: function (arg0_name, arg1_options) {
    //Convert from parameters
    var city_name = arg0_name;
    var options = (arg1_options) ? arg1_options : { pop_type: "all" };

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var city_obj = (typeof city_name != "object") ? getCity(city_name) : city_name;
    var total_growth = 0;
    var usr = main.users[city_obj.controller];

    //Calcualte total growth
    if (options.pop_type == "all") {
      for (var i = 0; i < all_pops.length; i++)
        total_growth += Math.ceil(
          city_obj.pops[all_pops[i]]*
          module.exports.getCityPopGrowthRate(city_obj, { pop_type: all_pops[i] })
        );
    } else {
      total_growth = Math.ceil(
        city_obj.pops[options.pop_type]*
        module.exports.getCityPopGrowthRate(city_obj, { pop_type: options.pop_type })
      );
    }

    //Return statement
    return total_growth;
  },

  /*
    getCityPopGrowthRate() - Returns the decimal percentage growth of a given city.
    options: {
      pop_type: "workers" - The pop type to calculate growth for. Defaults to 'all'
    }
  */
  getCityPopGrowthRate: function (arg0_name, arg1_options) {
    //Convert from parameters
    var city_name = arg0_name;
    var options = (arg1_options) ? arg1_options : { pop_type: "all" };

    //Declare local instance variables
    var city_obj = (typeof city_name != "object") ? getCity(city_name) : city_name;
    var scalar = 1;
    var usr = main.users[city_obj.controller];

    var local_growth_modifier = (options.pop_type != "all") ?
      usr.pops[`${options.pop_type}_growth_modifier`] : 1;

    //Local pop growth logic
    {
      //Calculate scalar
      if (city_obj.pops.population > config.defines.economy.urban_pop_growth_penalty_threshold) //-3% per million
        scalar -= Math.ceil(
          (city_obj.pops.population - config.defines.economy.urban_pop_growth_penalty_threshold)/1000000
        )*config.defines.economy.urban_pop_growth_penalty_per_million;

      //Calculate urban pop growth rate for chosen pop
      var local_pop_growth_rate = (
        local_growth_modifier*
        scalar*
        usr.modifiers.pop_growth_modifier
      );

      //Set local pop growth cap from economy defines
      var urban_growth_cap;
      for (var y = 0; y < config.defines.economy.urban_pop_growth_cap.length; y++) {
        var local_element = config.defines.economy.urban_pop_growth_cap[y];

        if (city_obj.pops.population >= local_element[0])
          urban_growth_cap = local_element[1];
      }

      if (urban_growth_cap)
        local_pop_growth_rate = Math.min(local_pop_growth_rate, urban_growth_cap);

      //Cap to maximum
      if (config.defines.economy.urban_pop_maximum_growth_rate)
        local_pop_growth_rate = Math.min(local_pop_growth_rate, config.defines.economy.urban_pop_maximum_growth_rate);

      //Occupation penalty
      if (city_obj.controller != city_obj.owner)
        local_pop_growth_rate = local_pop_growth_rate*config.defines.economy.occupation_pop_growth_penalty;

      //Make sure population can't drop by more than 100%
      if (local_pop_growth_rate < -1)
        local_pop_growth_rate = local_pop_growth_rate % 1;
    }

    //Return statement
    return local_pop_growth_rate;
  },

  getDemographics: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var pop_trackers = {};
    var provinces = getProvinces(user_id, { include_occupations: true });
    var total_population = 0;
    var usr = main.users[actual_id];

    //Iterate over provinces to fetch pop_trackers
    for (var i = 0; i < provinces.length; i++)
      if (provinces[i].pops) {
        for (var x = 0; x < all_pops.length; x++) {
          var local_value = returnSafeNumber(provinces[i].pops[all_pops[x]]);

          //Pops and used pops
          modifyValue(pop_trackers, all_pops[x], local_value);
          modifyValue(pop_trackers, `used_${all_pops[x]}`, returnSafeNumber(provinces[i].pops[`used_${all_pops[x]}`]));

          //Rural/urban statistics
          modifyValue(pop_trackers, `${provinces[i].type}_${all_pops[x]}`, local_value);
        }

        modifyValue(pop_trackers, `${provinces[i].type}_population`, provinces[i].population);
        total_population += returnSafeNumber(provinces[i].pops.population);
      }

    //Set global trackers
    pop_trackers.population = total_population;

    //Reset pops and used pops on usr.pops
    for (var i = 0; i < all_pops.length; i++) {
      delete usr.pops[all_pops[i]];
      delete usr.pops[`used_${all_pops[i]}`];

      delete usr.pops[`rural_${all_pops[i]}`];
      delete usr.pops[`urban_${all_pops[i]}`];
    }

    delete usr.pops.rural_population;
    delete usr.pops.urban_population;

    delete usr.pops.population;

    //Merge objects
    usr.pops = mergeObjects(usr.pops, pop_trackers);
    usr.population = returnSafeNumber(total_population);

    //Return statement
    return usr.pops;
  },

  getDemotionChance: function (arg0_province_id, arg1_pop_type) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_pop_type;

    //Declare local instance variables
    var demotion_chance = 0;
    var province_obj = main.provinces[province_id];

    if (province_obj.trackers) {
      var all_trackers = Object.keys(province_obj.trackers);

      for (var i = 0; i < all_trackers.length; i++) {
        var local_value = province_obj.trackers[all_trackers[i]];

        if (all_trackers[i].startsWith(`demote-${pop_type}`))
          demotion_chance += local_value;
      }
    }

    //Return statement
    return demotion_chance;
  },

  //getEmploymentPercentages() - Returns employment percentages for a pop type by building in a province
  getEmploymentPercentages: function (arg0_province_id, arg1_type) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;

    //Declare local instance variables
    var employment_obj = {};
    var employed_pops = 0;
    var province_obj = main.provinces[province_id];

    if (province_obj.buildings) {
      var all_pop_keys = Object.keys(province_obj.pops);

      for (var i = 0; i < all_pop_keys.length; i++)
        if (all_pop_keys[i].startsWith("wealth-")) {
          var split_wealth_key = all_pop_keys[i].split("-");

          var building_id = split_wealth_key[1];
          var local_pop_type = split_wealth_key[2];
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];

          if (local_pop_type == pop_type) {
            employment_obj[building_id] = local_wealth_pool.size;
            employed_pops += local_wealth_pool.size;
          }
        }

      //Adjust to percentage of employed_pops
      var all_employment_keys = Object.keys(employment_obj);

      for (var i = 0; i < all_employment_keys.length; i++) {
        var local_value = employment_obj[all_employment_keys[i]];

        employment_obj[all_employment_keys[i]] = local_value/employed_pops;
      }
    }

    //Return statement
    return sortObject(employment_obj);
  },

  getFaminePenalty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var government_obj = config.governments[usr.government];
    var famine_penalty = (government_obj.effect.famine_penalty) ? government_obj.effect.famine_penalty : 0.1;
    var usr = main.users[actual_id];

    //Return statement
    return Math.ceil(usr.population*famine_penalty);
  },

  /*
    getJobOpenings() - Fetches the total number of job openings for a pop type in a province based on specified criteria.
    options: {
      income: 15, - What the wage of this job should be >= to
      living_wage: true/false - Whether this is enough for the pop to afford config.defines.economy.staple_goods_categories
    }
  */
  getJobOpenings: function (arg0_province_id, arg1_pop_type, arg2_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_pop_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var total_openings = 0;

    if (province_obj)
      if (province_obj.buildings)
        for (var i = 0; i < province_obj.buildings.length; i++) {
          var local_building = province_obj.buildings[i];
          var local_positions = local_building[`${pop_type}_positions`];
          var local_wage = local_building[`${pop_type}_wage`];
          var meets_conditions = true;

          if (local_wage < returnSafeNumber(options.income))
            meets_conditions = false;
          if (options.living_wage) {
            var living_wage = getStapleGoodsPrice(pop_type);

            if (local_wage < living_wage)
              meets_conditions = false;
          }

          if (meets_conditions)
            total_openings += returnSafeNumber(province_obj.buildings[i][`${pop_type}_positions`]);
        }

    //Return statement
    return total_openings;
  },

  getMilitaryPops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var military_pop_types = [];

    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        military_pop_types.push(all_pops[i]);

    //Return statement
    return military_pop_types;
  },

  getNeedsCategoryTotalUtility: function (arg0_needs_category) {
    //Convert from parameters
    var needs_category = arg0_needs_category;

    //Declare local instance variables
    var all_needs_category_keys = Object.keys(needs_category);
    var total_utility = 0;

    if (!lookup.good_types)
      lookup.good_types = getGoodTypes();

    //Iterate over all_needs_category_keys
    for (var i = 0; i < all_needs_category_keys.length; i++) {
      var local_subobj = needs_category[all_needs_category_keys[i]];

      if (typeof local_subobj == "object") {
        var all_group_goods = Object.keys(local_subobj);

        for (var x = 0; x < all_group_goods.length; x++) {
          var local_define = config.defines.economy.good_categories[lookup.good_types[all_group_goods[x]]];
          var local_value = local_subobj[all_group_goods[x]];

          if (local_define)
            total_utility += local_define.marginal_utility*local_value;
        }
      }
    }

    //Return statement
    return total_utility;
  },

  //Updates config.pops with a new needs_importance object for buying order reference
  getNeedsImportance: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var defines_obj = config.defines.economy.good_categories;

    //Iterate over all pops and subcategories
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs) {
          var local_needs = local_pop.per_100k.needs;
          local_pop.needs_importance = {};

          var all_local_needs_categories = Object.keys(local_needs);
          var needs_importance = local_pop.needs_importance;

          for (var x = 0; x < all_local_needs_categories.length; x++) {
            var local_needs_category = local_needs[all_local_needs_categories[x]];
            var local_needs_obj = {};

            var all_local_needs_subcategories = Object.keys(local_needs_category);

            for (var y = 0; y < all_local_needs_subcategories.length; y++) {
              var local_needs_group = local_needs_category[all_local_needs_subcategories[y]];

              var all_local_needs = Object.keys(local_needs_group);
              var auto_priority = false;
              var total_importance = 0;
              var total_marginal_utility = 0;
              var type_count = {}; //Counts the number of goods of each type for automatic_priority setting

              for (var z = 0; z < all_local_needs.length; z++) {
                var local_good = lookup.all_goods[all_local_needs[z]];

                if (local_good)
                  if (local_good.type) {
                    var local_define = defines_obj[local_good.type];

                    if (local_define) {
                      //Add to total_importance and total_marginal_utility
                      total_importance += (local_define.importance != "unlimited") ?
                        returnSafeNumber(local_define.importance) : 99999;
                      total_marginal_utility += returnSafeNumber(local_define.marginal_utility);

                      modifyValue(type_count, local_good.type, 1);
                    }
                  }
              }

              //Average total_importance and total_marginal_utility, check for automatic_priority percentage
              var all_types = Object.keys(type_count);
              var average_importance = total_importance/all_local_needs.length;
              var average_marginal_utility = total_marginal_utility/all_local_needs.length;

              for (var z = 0; z < all_types.length; z++) {
                var local_define = defines_obj[all_types[z]];
                var local_value = type_count[all_types[z]];

                if (local_define)
                  if (local_value >= returnSafeNumber(local_define.automatic_priority))
                    auto_priority = true;
              }

              //Format local_needs_obj[all_local_needs_subcategories[y]]
              var local_needs_group = {
                importance: average_importance,
                marginal_utility: average_marginal_utility
              };

              if (auto_priority) local_needs_group.automatic_priority = true;
              local_needs_obj[all_local_needs_subcategories[y]] = local_needs_group;
            }

            //Set needs_importance object for pop
            local_pop.needs_importance[all_local_needs_categories[x]] = local_needs_obj;
          }

          //Iterate over all_local_needs_categories again to create a .buy_order array for categories
          var category_importances = [];

          for (var x = 0; x < all_local_needs_categories.length; x++) {
            var actual_importances = [];
            var local_needs_category = local_needs[all_local_needs_categories[x]];

            var actual_importance_array = [];
            var importance_array = []; //This will be sorted in descending order
            var total_importance = 0;

            var all_local_needs_subcategories = Object.keys(local_needs_category);

            for (var y = 0; y < all_local_needs_subcategories.length; y++) {
              var local_importance = local_pop.needs_importance[all_local_needs_categories[x]][all_local_needs_subcategories[y]];

              var local_actual_importance = (local_importance.automatic_priority) ?
                returnSafeNumber(local_importance.importance) : 99999;

              importance_array.push({ name: all_local_needs_subcategories[y], importance: local_actual_importance });
              total_importance += local_actual_importance;
            }

            //Sort importance_array
            importance_array.sort((a, b) => { b.importance - a.importance });

            for (var y = 0; y < importance_array.length; y++)
              actual_importance_array.push(importance_array[y]);
            local_pop[`${all_local_needs_categories[x]}-buy_order`] = actual_importance_array;

            category_importances.push({
              name: all_local_needs_categories[x],
              importance: total_importance/all_local_needs_subcategories.length
            });
          }

          //Sort category_importances
          category_importances.sort((a, b) => { b.importance - a.importance });

          for (var x = 0; x < category_importances.length; x++)
            actual_importances.push(category_importances[x].name);

          if (!local_pop.buy_order)
            local_pop.buy_order = actual_importances;
        }
    }
  },

  /*
    getNeedsTotalUtility() - Gets the total utility of a pop type.
    options: {
      staple_goods: true/false - Whether to restrict the scope to staple goods. All non-staple goods by default
    }
  */
  getNeedsTotalUtility: function (arg0_pop_type, arg1_options) {
    //Convert from parameters
    var pop_type = arg0_pop_type;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var pop_obj = config.pops[pop_type];
    var total_utility = 0;

    //Check if pop_obj.per_100k.needs exists
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs) {
          var all_needs_categories = Object.keys(pop_obj.per_100k.needs);

          //Iterate over all_needs_categories
          for (var i = 0; i < all_needs_categories.length; i++) {
            var is_staple = (config.defines.economy.staple_goods_categories.includes(all_needs_categories[i]));
            var local_value = pop_obj.per_100k.needs[all_needs_categories[i]];

            if (options.staple_goods) {
              if (is_staple)
                total_utility += module.exports.getNeedsCategoryTotalUtility(local_value);
            } else {
              if (!is_staple)
                total_utility += module.exports.getNeedsCategoryTotalUtility(local_value);
            }
          }
        }

    //Return statement
    return total_utility;
  },

  /*
    getNeedsUtilities() - Generates a total utility map of all pops for the relevant needs supercategory.
    options: {
      staple_goods: true/false - Whether to restrict the scope to staple-goods. All non-staple goods by default
    }
  */
  getNeedsUtilities: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var utility_obj = {};

    //Iterate over all_pops
    for (var i = 0; i < all_pops.length; i++)
      modifyValue(utility_obj, all_pops[i], module.exports.getNeedsTotalUtility(all_pops[i], options));

    //Return statement
    return utility_obj;
  },

  getPopClasses: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var class_obj = {};

    //Iterate over all_pops in config and append unique classes to class_obj
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.class) {
        if (!class_obj[local_pop.class]) class_obj[local_pop.class] = [];
        class_obj[local_pop.class].push(all_pops[i]);
      }
    }

    //Return statement
    return class_obj;
  },

  /*
    getPopMobility() - Returns statistical last turn pop mobility for a province.
    Returns: {
      promotion: { total: 24390 },
      demotion: { total: 4102 },

      change: 2148 - Total change in pop (as driven by social mobility)
    }
  */
  getPopMobility: function (arg0_province_id, arg1_pop_type) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_pop_type;

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var total_demoted = 0;
    var total_promoted = 0;
    var return_obj = {
      promotion: {},
      demotion: {}
    };

    if (province_obj)
      if (province_obj.trackers) {
        var all_province_trackers = Object.keys(province_obj.trackers);

        for (var i = 0; i < all_province_trackers.length; i++) {
          var local_value = province_obj.trackers[all_province_trackers[i]];
          var split_key = all_province_trackers[i].split("-");

          if (split_key[0] == "demote")
            if (split_key[1] == pop_type) {
              modifyValue(return_obj.demotion, split_key[2], local_value);
              total_demoted += local_value;
            }
          if (split_key[0] == "promote")
            if (split_key[2] == pop_type) {
              modifyValue(return_obj.promotion, split_key[1], local_value);
              total_promoted += local_value;
            }
        }

        return_obj.demotion.total = total_demoted;
        return_obj.promotion.total = total_promoted;
      }

    //Set return_obj.change
    return_obj.change = total_promoted - total_demoted;

    //Return statement
    return return_obj;
  },

  getPopModifier: function (arg0_user, arg1_type, arg2_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var total_modifier = 0;
    var total_pop_type = module.exports.getTotalPopManpower(user_id, pop_type);
    var usr = main.users[actual_id];

    //Regular error trapping just in case the specified modifier does not exist
    try {
      //Calculate total_modifier
      total_modifier = (total_pop_type/100000)*pop_obj.per_100k[raw_modifier];

      //Make sure to implement a proper cap
      if (pop_obj.max_modifier_limit)
        if (pop_obj.max_modifier_limit[raw_modifier])
          if (total_modifier > pop_obj.max_modifier_limit[raw_modifier])
            total_modifier = pop_obj.max_modifier_limit[raw_modifier];

      //Return statement
      return total_modifier;
    } catch (e) {
      log.error(`Could not calculate total pop modifier of type ${pop_type} for modifier ${raw_modifier}: ${e}`);
      console.error(e);
    }
  },

  /*
    getPopNeeds() - Fetches generic pop needs for a given pop type
    options: {
      province_id: "4407" - Uses wealth pools to account for rounding issues
    }
  */
  getPopNeeds: function (arg0_type, arg1_amount, arg2_needs_category, arg3_options) {
    //Convert from parameters
    var pop_type = arg0_type;
    var amount = (arg1_amount != undefined) ? parseInt(arg1_amount) : 100000; //per_100k is the default needs scope
    var needs_category = arg2_needs_category;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var goods_obj = {};
    var needs_obj = (typeof needs_category != "object" && needs_category) ? needs_category.trim().toLowerCase() : undefined;
    var pop_obj = config.pops[pop_type];
    var wealth_pools_amount = 0;

    //Fetch needs_obj recursively
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs)
          try {
            needs_obj = (needs_category) ? JSON.parse(JSON.stringify(
              getSubobject(pop_obj.per_100k.needs, needs_category)
            )) : JSON.parse(JSON.stringify(pop_obj.per_100k.needs));

            //Fetch wealth_pools_amount
            if (options.province_id) {
              var province_obj = main.provinces[options.province_id];

              if (province_obj)
                if (province_obj.pops) {
                  var all_pop_keys = Object.keys(province_obj.pops);

                  for (var i = 0; i < all_pop_keys.length; i++)
                    if (all_pop_keys[i].startsWith("wealth-")) {
                      var local_pop_type = all_pop_keys[i].split("-")[2];

                      if (local_pop_type == pop_type)
                        wealth_pools_amount++;
                    }
                }
            }
          } catch {
            needs_obj = {};
          }

    //Multiply everything in needs_obj by a given amount
    needs_obj = removeZeroes(multiplyObject(needs_obj, amount/100000, false, "ceil"));

    //Account for rounding errors
    needs_obj = addObject(needs_obj, wealth_pools_amount);

    return needs_obj;
  },

  /*
    getPopNeedsFulfilment() - Returns the total fulfilment of a set of pop needs.
    options: {
      needs_category: "food", - Which needs category to return fulfilment/variety for. Defaults to all
      return_object: true/false, - Whether to return the variety of goods and fulfilment used as a single object: { fulfilment: (Number), variety: (Number) }
      restrict_goods: ["food", "bread"], - Goods to restrict calculations to
      return_variety: true/false - Whether or not to return the variety of goods used in fulfilment instead of total fulfilment
    }
  */
  getPopNeedsFulfilment: function (arg0_goods, arg1_type, arg2_amount, arg3_options) {
    //Convert from parameters
    var goods_obj = arg0_goods; //These are the goods fulfilment is calculated against
    var pop_type = arg1_type;
    var amount = (arg2_amount) ? parseInt(arg2_amount) : 100000;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var all_goods = Object.keys(goods_obj);
    var allowed_goods = (!options.restrict_goods) ? lookup.all_good_names : getList(options.restrict_goods);
    var multiplier = amount/100000;
    var pop_obj = config.pops[pop_type];
    var total_fulfilment = 0;
    var total_variety = 0;

    //Make sure pop has needs to begin with
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs) {
          var all_needs_groups = Object.keys(pop_obj.per_100k.needs).reverse();
          var is_needs_category = false;

          if (!options.needs_category) is_needs_category = true;
          if (pop_obj.per_100k.needs[options.needs_category]) {
            all_needs_groups = [options.needs_category];
            is_needs_category = true;
          }

          //Iterate through all_needs_keys in needs_obj and figure out its total fulfilment
          if (is_needs_category) {
            //all_needs_groups are things like "luxury_goods" in this boolean
            for (var i = 0; i < all_needs_groups.length; i++) {
              var divide_goods_obj = {}; //Total amount of categories that need a certain good key
              var local_needs_group = pop_obj.per_100k.needs[all_needs_groups[i]];

              var fulfilment_array = [];
              var variety_array = [];

              var all_local_needs_categories = Object.keys(local_needs_group);
              var total_need_groups = all_local_needs_categories.length;

              //Remove total_need_groups
              for (var x = 0; x < all_local_needs_categories.length; x++) {
                var has_subgood = false;

                var local_needs_category = local_needs_group[all_local_needs_categories[x]];

                if (!options.restrict_goods) has_subgood = true;
                if (options.restrict_goods)
                  for (var y = 0; y < options.restrict_goods.length; y++)
                    if (local_needs_category[options.restrict_goods[y]])
                      has_subgood = true;

                if (!has_subgood)
                  total_need_groups--;
              }

              //Parse local fulfilment and variety for each
              for (var x = 0; x < all_local_needs_categories.length; x++) {
                var has_subgood = false;

                //These are now objects like staple_goods.basics
                var local_needs_category = local_needs_group[all_local_needs_categories[x]];

                var all_local_goods = Object.keys(local_needs_category);
                var percent_fulfilled = 0;
                var percent_variety = 0;
                var total_goods = 0;

                if (!options.restrict_goods) has_subgood = true;
                if (options.restrict_goods)
                  for (var y = 0; y < options.restrict_goods.length; y++)
                    if (local_needs_category[options.restrict_goods[y]])
                      has_subgood = true;

                //Calculate total_goods
                for (var y = 0; y < all_local_goods.length; y++) {
                  var local_value = local_needs_category[all_local_goods[y]];

                  if (allowed_goods.includes(all_local_goods[y]))
                    total_goods += returnSafeNumber(local_value*multiplier);
                }

                //Iterate over all_local_goods to check for fulfilment; subtract resultant goods_obj[all_local_goods[y]] from goods_obj
                for (var y = 0; y < all_local_goods.length; y++)
                  if (allowed_goods.includes(all_local_goods[y])) {
                    var local_good = lookup.all_goods[all_local_goods[y]];

                    var local_allowance = returnSafeNumber(goods_obj[all_local_goods[y]]);
                    var local_goods_amount = (!options.restrict_goods) ? all_local_goods.length : options.restrict_goods.length;
                    var local_value = local_needs_category[all_local_goods[y]]*multiplier;

                    //Calculate current_fulfillment, variety
                    var current_fulfillment = local_allowance/local_value;

                    percent_fulfilled += current_fulfillment*(local_value/total_goods);

                    if (local_allowance > 0)
                      percent_variety += 1/local_goods_amount;

                    //Subtract from goods_obj[all_local_goods[y]]
                    goods_obj[all_local_goods[y]] = Math.max(goods_obj[all_local_goods[y]] - local_value, 0);

                    //Special variety parsing logic for local_good.type 'category'
                    if (local_good.type == "category") {
                      var all_subgood_keys = getSubobjectKeys(local_good, { exclude_keys: reserved.goods, only_objects: true });

                      percent_variety = 0;

                      for (var z = 0; z < all_subgood_keys.length; z++) {
                        var local_subgood = lookup.all_goods[all_subgood_keys[z]];

                        if (local_subgood) {
                          var local_subgood_allowance = goods_obj[all_subgood_keys[z]];

                          if (local_subgood_allowance > 0)
                            percent_variety += returnSafeNumber(1/all_subgood_keys.length);
                        }
                      }
                    }
                  }

                //Push percent_fulfilled, percent_variety to fulfilment_array, variety_array
                if (has_subgood) {
                  fulfilment_array.push(Math.min(percent_fulfilled, 1));
                  variety_array.push(Math.min(percent_variety, 1));
                }
              }
              total_fulfilment += returnSafeNumber(getAverage(fulfilment_array)*(1/total_need_groups));
              total_variety += returnSafeNumber(getAverage(variety_array)*(1/total_need_groups));
            }
          } else {
            //This is a junior category such as .luxury_goods.food, treat it as such
            var needs_obj = module.exports.getPopNeeds(pop_type, amount, options.needs_category); //Already pre-multiplied
            var total_goods = 0;

            if (needs_obj) {
              //Calculate total_goods
              var all_needs_keys = Object.keys(needs_obj);
              var needs_amount = (!options.restrict_goods) ? all_needs_keys.length : options.restrict_goods.length;

              for (var i = 0; i < all_needs_keys.length; i++)
                if (allowed_goods.includes(all_needs_keys[i]))
                  total_goods += returnSafeNumber(needs_obj[all_needs_keys[i]]);

              //Calculate total_fulfilment and total_variety
              for (var i = 0; i < all_needs_keys.length; i++)
                if (allowed_goods.includes(all_needs_keys[i])) {
                  var local_allowance = returnSafeNumber(goods_obj[all_needs_keys[i]]);
                  var local_value = needs_obj[all_needs_keys[i]];

                  //Add to total_fulfilment; total_variety
                  total_fulfilment += Math.min((local_allowance/local_value)*(1/needs_amount));

                  if (local_allowance > 0)
                    total_variety += 1/needs_amount;

                  //Subtract from goods_obj[all_needs_keys[i]];
                  if (local_allowance >= Math.ceil(local_value)) {
                    goods_obj[all_needs_keys[i]] -= Math.ceil(local_value);
                  } else {
                    goods_obj[all_needs_keys[i]] = 0;
                  }
                }
            }
          }
        }

    //Return statement
    if (!options.return_object) {
      return (!options.return_variety) ? total_fulfilment : total_variety;
    } else {
      return {
        fulfilment: total_fulfilment,
        variety: total_variety
      };
    }
  },

  getPopulation: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var usr = main.users[actual_id];

    //Update pops
    module.exports.getDemographics(user_id);

    //Return statement
    return usr.pops.population;
  },

  getPromotionChance: function (arg0_province_id, arg1_pop_type) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_pop_type;

    //Declare local instance variables
    var promotion_chance = 0;
    var province_obj = main.provinces[province_id];

    if (province_obj.trackers) {
      var all_trackers = Object.keys(province_obj.trackers);

      for (var i = 0; i < all_trackers.length; i++) {
        var local_value = province_obj.trackers[all_trackers[i]];

        if (all_trackers[i].startsWith(`promote-${pop_type}`))
          promotion_chance += local_value;
      }
    }

    //Return statement
    return promotion_chance;
  },

  //getProvinceBirthRate() - General modifier on births, not actually the true province birth rate
  getProvinceBirthRate: function (arg0_user, arg1_province_id) {
    //Convert from parameters
    var user_id = arg0_user;
    var province_id = arg1_province_id;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var births = {}; //Split by pop type
    var province_obj = main.provinces[province_id];
    var total_fertility = 0;
    var usr = main.users[actual_id];

    //Famine guard clause
    if (usr.has_famine)
      return {};

    //Check if province exists and for urban/rural growth dichotomy
    if (province_obj)
      if (province_obj.controller == province_obj.owner)
        if (province_obj.type == "urban") {
          var local_pop_growth = module.exports.getCityPopGrowth(province_obj, { pop_type: all_pops[i] });

          modifyValue(births, all_pops[i], (local_pop_growth/province_obj.pops.population) + 1);
          total_fertility += (local_pop_growth/province_obj.pops.population) + 1;
        } else {
          if (!province_obj.pop_cap)
            province_obj.pop_cap = (config.defines.economy.rural_pop_cap) ?
              randomNumber(config.defines.economy.rural_pop_cap[0], config.defines.economy.rural_pop_cap[1]) :
              randomNumber(120000, 140000);

          //Calculate rural pop growth for all pops
          if (province_obj.pops.population < province_obj.pop_cap)
            for (var i = 0; i < all_pops.length; i++) {
              var local_pop_growth = Math.ceil(province_obj.pops[all_pops[i]]*usr.pops[`${all_pops[i]}_growth_modifier`]*usr.modifiers.pop_growth_modifier) - province_obj.pops[all_pops[i]];

              modifyValue(births, all_pops[i], (local_pop_growth/province_obj.pops.population) + 1);
            }
        }

    //Return statement
    return births;
  },

  /*
    getProvinceEducation() - Returns province education level object by percentage.
    options: {
      return_sum: true/false - Optional. Whether to return sum totals for each education level instead of percentages. False by default
    }
  */
  getProvinceEducation: function (arg0_province_id, arg1_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var educated_total = 0;
    var education_obj = {};
    var province_obj = main.provinces[province_id];

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("el_")) {
            var local_education_level = parseInt(all_pop_keys[i].replace("el_", ""));
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (!isNaN(local_education_level)) {
              modifyValue(education_obj, local_education_level, local_value);
              educated_total += local_value;
            }
          }

        modifyValue(education_obj, "0", province_obj.pops.population - educated_total, true);
      }

    //Standardise to percentage
    if (!options.return_sum)
      education_obj = standardisePercentage(education_obj, province_obj.pops.population);

    //Return statement
    return education_obj;
  },

  getProvinceEducationLevel: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var weighted_total = 0;

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("el_")) {
            var local_education_level = parseInt(all_pop_keys[i].replace("el_", ""));
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (!isNaN(local_education_level))
              weighted_total += (local_education_level/100)*local_value;
          }
      }

    //Return statement
    return weighted_total/province_obj.pops.population;
  },

  //getProvinceEmployees() - Returns the total number of employed pops in a province
  getProvinceEmployees: function (arg0_province_id, arg1_pop_types) { //[WIP] - Finish province employment
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_types = (arg1_pop_types) ? getList(arg1_pop_types) : Object.keys(config.pops);

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var total_employed = 0;

    //Iterate over pop_types to count total_employed
    if (province_obj.pops)
      for (var i = 0; i < pop_types.length; i++)
        total_employed += returnSafeNumber(province_obj.pops[`used_${pop_types[i]}`]);

    //Return statement
    return total_employed;
  },

  getProvinceEnslavedPercentage: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var enslaved_population = 0;
    var province_obj = main.provinces[province_id];

    //Iterate over all_pops and check for .slave_pop
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (typeof local_pop == "object")
        if (local_pop.slave_pop)
          enslaved_population += returnSafeNumber(province_obj.pops[all_pops[i]]);
    }

    return enslaved_population/province_obj.pops.population;
  },

  //getProvinceEmployment() - Returns the overall % of employed pops in a province
  getProvinceEmployment: function (arg0_province_id, arg1_pop_types) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_types = (arg1_pop_types) ? getList(arg1_pop_types) : Object.keys(config.pops);

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var total_employed = module.exports.getProvinceEmployees(province_id, pop_types);

    //Return statement
    return (province_obj.pops) ? total_employed/province_obj.pops.population : 0;
  },

  getProvinceSOL: function (arg0_province_id, arg1_pop_types) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_types = (arg1_pop_types) ? getList(arg1_pop_types) : Object.keys(config.pops);

    //Declare local instance variables
    var pop_scope = module.exports.selectPops({
      province_id: province_id,
      pop_types: pop_types
    });
    var sol = module.exports.getSOL(pop_scope);

    //Return statement
    return sol;
  },

  getProvinceWealth: function (arg0_province_id, arg1_pop_types) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_types = (arg1_pop_types) ? getList(arg1_pop_types) : Object.keys(config.pops);

    //Declare local instance variables
    var wealth = 0;
    var province_obj = main.provinces[province_id];

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("wealth-")) {
            var split_key = all_pop_keys[i].split("-");

            if (pop_types.includes(split_key[2])) {
              var local_wealth_pool = province_obj.pops[all_pop_keys[i]];

              wealth += returnSafeNumber(local_wealth_pool.wealth);
            }
          }
      }

    //Return statement
    return wealth;
  },

  //getRelevantPops() - Returns an array of all pop keys with more than 0 population in a player country
  getRelevantPops: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_keys = Object.keys(config.pops);
    var relevant_pops = [];
    var usr = main.users[actual_id];

    //Iterate over all_pop_keys and check if usr.pops finds a match
    for (var i = 0; i < all_pop_keys.length; i++)
      if (config.pops[all_pop_keys[i]]) {
        var local_pop = config.pops[all_pop_keys[i]];
        var meets_conditions = true;

        //Global pop limit handling
        if (local_pop.disabled)
          meets_conditions = false;
        if (local_pop.industrial_pop)
          if (main.date.year < 1815)
            meets_conditions = false;

        if (meets_conditions)
          if (!relevant_pops.includes(all_pop_keys[i]))
            relevant_pops.push(all_pop_keys[i]);
      }

    //Return statement
    return relevant_pops;
  },

  //getSOL() - Fetches total standard of living for a pop based on the total utility of the fulfilled needs of pops +50% other factors (standardised to 0-100%)
  getSOL: function (arg0_pop_scope) { //[WIP] - Finish function body
    //Convert from parameters
    var pop_scope = arg0_pop_scope;

    //Declare local instance variables
    var all_pop_scope_keys = Object.keys(pop_scope);
    var other_utility = 0; //Housing, etc.
    var province_obj = main.provinces[pop_scope.province_id];
    var total_luxury_categories = 0;
    var total_luxury_utility = 0;
    var total_staple_categories = 0;
    var total_staple_utility = 0;

    //Declare local scalars
    var housing_scalar = returnSafeNumber(province_obj.housing)/province_obj.pops.population; //[WIP] - Revisit in future

    //Iterate over all_pop_scope_keys
    for (var i = 0; i < all_pop_scope_keys.length; i++)
      if (all_pop_scope_keys[i].endsWith("-fulfilment")) {
        var local_category_name = all_pop_scope_keys[i].replace("-fulfilment", "");
        var local_value = pop_scope[all_pop_scope_keys[i]];

        var is_staple = (config.defines.economy.staple_goods_categories.includes(local_category_name));

        if (is_staple) {
          total_staple_categories++;
          total_staple_utility += local_value;
        } else {
          total_luxury_categories++;
          total_luxury_utility += local_value;
        }
      }

    total_staple_utility = total_staple_utility/total_staple_categories;
    total_luxury_utility = total_luxury_utility/total_luxury_categories;

    other_utility = housing_scalar;

    //Return statement
    return total_staple_utility*config.defines.economy.staple_sol +
      total_luxury_utility*config.defines.economy.luxury_sol +
      other_utility*config.defines.economy.other_sol;
  },

  getTotalActiveDuty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var total_active_duty = 0;
    var usr = main.users[actual_id];

    //Fetch total active duty
    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        total_active_duty += usr.pops[`used_${all_pops[i]}`];

    //Return statement
    return total_active_duty;
  },

  getTotalPopConsumption: function (arg0_user, arg1_mode) {
    //Convert from parameters
    var user_id = arg0_user;
    var mode = arg1_mode; //"staple_goods", "luxury_goods"

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var consumption_obj = {};
    var usr = main.users[actual_id];

    //Iterate over all_pops for user and merge with consumption_obj
    for (var i = 0; i < all_pops.length; i++)
      try {
        var local_pop = config.pops[all_pops[i]];

        if (local_pop.per_100k)
          if (local_pop.per_100k.needs) {
            var total_pop_amount = returnSafeNumber(usr.pops[all_pops[i]]);
            var total_pop_needs = getPopNeeds(all_pops[i], total_pop_amount, mode);

            consumption_obj = mergeObjects(consumption_obj, total_pop_needs);
          }
      } catch (e) {
        log.warn(`${all_pops[i]} ran into an error whilst trying to fetch consumption_obj!`);
        console.log(e);
      }

    //Return statement
    return flattenObject(consumption_obj);
  },

  getTotalPopManpower: function (arg0_user, arg1_type, arg2_raw_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_raw_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var usr = main.users[actual_id];

    var availability_modifier = (pop_obj.military_pop) ?
      usr.modifiers.maximum_manpower*usr.modifiers.national_manpower
      : 1;

    //Return statement
    return (!raw_modifier) ? Math.ceil(usr.pops[pop_type]*availability_modifier) : availability_modifier;
  },

  //getTotalPopMobility() - Fetches total pop mobility statistics for an entire country's controlled provinces
  getTotalPopMobility: function (arg0_user, arg1_pop_type) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_pop_type;

    //Declare local instance variables
    var controlled_provinces = getProvinces(user_id, { include_occupations: true });
    var return_obj = {};

    //Iterate over controlled_provinces
    for (var i = 0; i < controlled_provinces.length; i++)
      return_obj = mergeObjects(return_obj, module.exports.getPopMobility(controlled_provinces[i].id, pop_type));

    //Return statement
    return return_obj;
  },

  //getUnemployedPops() - Returns the total unemployed pops of a given type in a province
  getUnemployedPops: function (arg0_province_id, arg1_type, arg2_no_subsistence) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var no_subsistence = arg2_no_subsistence;

    //Declare local instance variables
    var employed_pops = 0;
    var province_obj = main.provinces[province_id];

    var all_pop_keys = Object.keys(province_obj.pops);

    //Iterate over all_pop_keeps for wealth_ pools
    for (var i = 0; i < all_pop_keys.length; i++)
      if (all_pop_keys[i].startsWith("wealth-")) {
        var split_wealth_key = all_pop_keys[i].split("-");

        var local_pop_type = split_wealth_key[2];

        if (local_pop_type == pop_type) {
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
          var meets_conditions = true;

          if (no_subsistence && local_wealth_pool.subsistence)
            meets_conditions = false;

          if (meets_conditions)
            employed_pops += returnSafeNumber(local_wealth_pool.size);
        }
      }

    //Return statement
    return returnSafeNumber(province_obj.pops[all_pop_keys[i]] - employed_pops);
  },

  mergePopScopes: function (arg0_pop_scope, arg1_pop_scope) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var ot_pop_scope = arg1_pop_scope;

    //Declare local instance variables
    var all_ot_pop_scope_keys = Object.keys(ot_pop_scope);
    var all_ot_pop_scope_tags = Object.keys(ot_pop_scope.tags);
    var all_pop_scope_keys = Object.keys(pop_scope);
    var all_pop_scope_tags = Object.keys(pop_scope.tags);
    var contributing_totals = {}; //{ pop_scope: 851903, ot_pop_scope: 481822 }. Tracks ALL tag totals for each pop_scope compared to ot_pop_scope
    var new_pop_scope = {
      tags: {}
    };

    //Fetch set intersection of all_ot_pop_scope_tags and all_pop_scope_tags and push it to new_pop_scope.tags
    for (var i = 0; i < all_pop_scope_tags.length; i++) {
      var local_ot_value = ot_pop_scope.tags[all_pop_scope_tags[i]]; //Intersect operation
      var local_value = pop_scope.tags[all_pop_scope_tags[i]];

      if (local_value && local_ot_value) {
        var local_min_clamp = Math.min(local_ot_value, local_value);
        var local_total = local_value + local_ot_value;
        new_pop_scope.tags[all_pop_scope_tags[i]] = local_min_clamp;

        modifyValue(contributing_totals, "pop_scope", (local_value/local_total)*local_min_clamp);
        modifyValue(contributing_totals, "ot_pop_scope", (local_ot_value/local_total)*local_min_clamp);
      }
    }

    //Based on contributing_totals; merge top level key-values via weighted average. If counterpart is undefined, assume 0
    var contributing_total = contributing_totals.pop_scope + contributing_totals.ot_pop_scope;
    contributing_totals.pop_percentage = contributing_totals.pop_scope/contributing_total;
    contributing_totals.ot_pop_percentage = contributing_totals.ot_pop_scope/contributing_total;

    for (var i = 0; i < all_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }
    for (var i = 0; i < all_ot_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }

    //Return statement
    return new_pop_scope;
  },

  /*
    modifyEducationLevel() - Changes the education level of selected pops in a given province. [REVISIT] - Add pop selector options in the future.
    options: {
      province_id: "4407", - Which province ID should be targeted by this function?

      min: 0, - Optional. 0 by default. For which brackets should the education level be raised? (Lower bound)
      max: 0, - Optional. 1 by default. For which brackets should the education level be raised?

      capacity: 50000, - Optional. Entire province population by default. How many people should be raised in terms of education at a time?
      value: 0.05 - How much should education levels within these brackets up to capacity be modified?
    }
  */
  modifyEducationLevel: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var province_obj = main.provinces[options.province_id];
    var total_eligible = 0;

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        //Set defaults
        var max = Math.min(returnSafeNumber(options.max), 1);
        var min = Math.max(returnSafeNumber(options.min), 0);

        var capacity = (options.capacity) ? options.capacity : province_obj.pops.population;
        var value = returnSafeNumber(options.value);

        //Fetch education_profile_obj - lists current education profile; then standardise to percentages so that they can be moved up by their respective steps proportionally
        var education_profile_obj = {};
        var education_percentage_obj = {};

        //Iterate over all_pop_keys
        for (var i = 0; i < all_pop_keys.length; i++) {
          var local_value = province_obj.pops[all_pop_keys[i]];

          if (all_pop_keys[i].startsWith("el_")) {
            var local_key = all_pop_keys[i].replace("el_", "");
            var local_education_level = parseInt(local_key);

            if (local_education_level >= min && local_education_level <= max) {
              education_profile_obj[local_education_level] = local_value;
              total_eligible += local_value;
            }
          }
        }

        //Zero handler for total_eligible
        var uneducated_population = province_obj.pops.population - total_eligible;

        if (min <= 0)
          education_profile_obj[0] = uneducated_population;

        //Iterate over education_profile_obj to fetch education_percentage_obj
        var all_education_keys = Object.keys(education_profile_obj);

        for (var i = 0; i < all_education_keys.length; i++)
          education_percentage_obj[all_education_keys[i]] = education_profile_obj[all_education_keys[i]]/total_eligible;

        //Modify their actual education values now
        var new_keys = [];
        var rounding_overflow = 0;

        for (var i = 0; i < all_education_keys.length; i++) {
          var local_change = Math.ceil(capacity*education_percentage_obj[all_education_keys[i]]);
          var local_key = `el_${all_education_keys[i]}`;
          var new_value = parseInt(all_education_keys[i]) + Math.min(Math.ceil(value*100), 100);

          var new_key = `el_${new_value}`;

          if (local_change % 1 != 0) rounding_overflow++;

          modifyValue(province_obj.pops, local_key, local_change*-1);
          modifyValue(province_obj.pops, new_key, local_change);

          if (!new_keys.includes(new_key)) new_keys.push(new_key);

          //Clear useless keys
          if (province_obj.pops[local_key] <= 0)
            delete province_obj.pops[local_key];
          if (province_obj.pops[new_key] <= 0)
            delete province_obj.pops[new_key];
        }

        //Subtract rounding_overflow as much as possible
        for (var i = 0; i < new_keys.length; i++)
          if (rounding_overflow > 0) {
            var local_value = province_obj.pops[new_keys[i]];
            var value_removed = Math.min(local_value, rounding_overflow);

            modifyValue(province_obj.pops, new_keys[i], value_removed*-1);
            rounding_overflow -= value_removed;

            if (province_obj.pops[new_keys[i]] <= 0)
              delete province_obj.pops[new_keys[i]];
          }
      }
  },

  /*
    movePops() - Moves pops from one province to another.
    options: {
      do_not_layoff: true/false - Optional. False by default. Whether to layoff pops from their current jobs; if already laid off, switch to true.
    }
  */
  movePops: function (arg0_province_id, arg1_pop_scope, arg2_province_id, arg3_options) { //[WIP] - Make sure that original province still has enough tags to move out, lower bound it
    //Convert from parameters
    var from_province_id = arg0_province_id;
    var pop_scope = arg1_pop_scope;
    var to_province_id = arg1_province_id;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var from_building_map = getBuildingMap(from_province_id);
    var from_province = main.provinces[from_province_id];
    var to_province = main.provinces[to_province_id];

    //Initialise pop_scope
    if (!pop_scope.size) {
      pop_scope.province_id = from_province_id;
      pop_scope = module.exports.selectPops(pop_scope);
    }

    //Move pops if pop_scope returned something
    if (pop_scope.size > 0) {
      //Handle tags
      var all_tags = Object.keys(pop_scope.tags);

      for (var i = 0; i < all_tags.length; i++) {
        var local_value = pop_scope.tags[all_tags[i]];

        //Move pop attributes
        modifyValue(from_province.pops, all_tags[i], local_value*-1, true);
        modifyValue(to_province.pops, all_tags[i], local_value);

        //Layoff pops
        if (all_tags[i].startsWith("wealth-"))
          if (!options.do_not_layoff) {
            var split_wealth_key = all_tags[i].split("-");

            var local_building = building_map[split_wealth_key[1]];

            layoffWorkers(local_building, split_wealth_key[2], local_value);
          }
      }

      //Subtract from from_province.pops.population
      from_province.pops.population -= pop_scope.size;
      to_province.pops.population += pop_scope.size;
    }
  },

  multiplyPops: function (arg0_pop_scope, arg1_amount, arg2_is_birth) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var amount = arg1_amount;
    var is_birth = arg2_is_birth;

    //Declare local instance variables
    var all_pop_scope_tags = Object.keys(pop_scope.tags);
    var province_population = main.provinces[pop_scope.province_id].pops.population;

    if (pop_scope.size > 0) {
      var max_amount = (province_population/pop_scope.size);

      amount = Math.min(amount, max_amount);

      pop_scope.size = Math.min(Math.ceil(pop_scope.size*amount), province_population);

      if (!is_birth) {
        pop_scope.income = Math.ceil(pop_scope.income*amount);
        pop_scope.wealth = Math.ceil(pop_scope.wealth*amount);
      }

      //Iterate over all_pop_scope_tags
      for (var i = 0; i < all_pop_scope_tags.length; i++) {
        var is_mutable = false;
        var local_value = pop_scope.tags[all_pop_scope_tags[i]];

        //Check if pop tag is born with or not
        if (all_pop_scope_tags[i].startsWith("b_"))
          is_mutable = true;
        if (all_pop_scope_tags[i].startsWith("el_"))
          is_mutable = true;
        if (all_pop_scope_tags[i].startsWith("wealth-"))
          is_mutable = true;

        if ((!is_mutable && is_birth) || !is_birth) {
          pop_scope.tags[all_pop_scope_tags[i]] = Math.ceil(local_value*amount);
        } else if (is_birth) {
          delete pop_scope.tags[all_pop_scope_tags[i]];
        }
      }
    }

    //Return statement
    return pop_scope;
  },

  parsePops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);

    //Process pop objects
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      //Set icon values
      if (local_pop.icon) local_pop.icon = config.icons[local_pop.icon];
    }
  },

  /*
    processEmployment() - Processes the job market for a given pop type in a province
    options: {
      sorted_wage_obj: {}, - Optimisation parameter. The sorted wage object for the province.
      unemployed_pops: 3194 - Optimisation parameter. The total number of unemployed pops sitting in this province
    }
  */
  processEmployment: function (arg0_province_id, arg1_type, arg2_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var building_map = getBuildingMap(province_id);
    var province_obj = main.provinces[province_id];
    var unemployed_pops = (options.unemployed_pops) ? options.unemployed_pops : module.exports.getUnemployedPops(province_id, pop_type);

    //All unemployed pops are looking for a job
    if (province_obj)
      if (province_obj.buildings) {
        var building_wages = (options.sorted_wage_obj) ? options.sorted_wage_obj : getBuildingWages(province_id, pop_type);

        //Iterate over all_building_wages and select the range from the top of the current number of keys
        var all_building_wages = Object.keys(building_wages);
        var is_strict = config.defines.economy.strict_job_seeking;
        var job_seeking_range = config.defines.economy.job_seeking_range;

        var valid_building_range = [
          Math.floor(all_building_wages.length*job_seeking_range[0]),
          Math.floor(all_building_wages.length*job_seeking_range[1]) - 1
        ];
        valid_building_range.sort(function (a, b) { return a - b });

        for (var i = valid_building_range[1] - 1; i >= ((is_strict) ? valid_building_range[0] : 0); i++) {
          var building_id = all_building_wages[i];
          var local_building = province_obj.buildings[building_map[building_id]];
          var local_key = `wealth-${building_id}-${pop_type}`;

          //If they're currently hiring, take all the workers you can according to random_chance_roll. If positions max out, the unemployed_pops figure rolls over
          if (building_obj[`${pop_type}_positions`]) {
            var random_chance_roll = Math.random();
            var random_hirees = Math.floor(unemployed_pops*random_chance_roll);

            if (unemployed_pops > 0) {
              var available_positions = building_obj[`${pop_type}_positions`];

              if (available_positions > random_hirees) {
                building_obj[`${pop_type}_positions`] -= random_hirees;
                province_obj.pops[local_key].size += random_hirees;
                unemployed_pops -= random_hirees;
              } else {
                province_obj.pops[local_key].size += available_positions;
                unemployed_pops -= available_positions;

                //Delete building_obj[`${pop_type}_positions`] since all the positions have been hired
                delete building_obj[`${pop_type}_positions`];
              }
            }
          }
        }
      }
  },

  /*
    processPop() - Processes pop type per province
    options: {
      sorted_wage_obj: {} - Optimisation parameter. The sorted wage object for the province.
    }
  */
  processPop: function (arg0_province_id, arg1_type, arg2_options) { //[WIP] - Add pop growth/decline/needs/migration later
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var building_map = getBuildingMap(province_id);
    var config_obj = config.pops[pop_type];
    var current_median = province_obj[`${pop_type}_median_wage`];
    var current_year = Math.floor(main.date.year);
    var has_demotes = false;
    var has_promotes = false;
    var pop_scope = module.exports.selectPops({
      province_id: province_id,
      pop_types: [pop_type]
    });
    var province_obj = main.provinces[province_id];
    var user_id = province_obj.controller;
    var usr = main.users[user_id];

    var external_migration_table = lookup[`${province_obj.controller}-external_migration_attraction`];
    var internal_migration_table = lookup[`${province_obj.controller}-migration_attraction`];

    var all_external_provinces = Object.keys(external_migration_table);
    var all_internal_provinces = Object.keys(internal_migration_table);

    //Initialise variables
    {
      if (config_obj.demotes_to) has_demotes = true;
      if (config_obj.promotes_to) has_promotes = true;
    }

    //Pop Births and Deaths
    {
      //Get province growth scalar
      var birth_scalar = province_obj.trackers.births[pop_type];

      //Birth handling
      if (!usr.has_famine) {
        var birth_chance = parsePopLimit(config.births, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Iterate over birth_chance.selectors - [pop_scope, value]
        for (var i = 0; i < birth_chance.selectors.length; i++) {
          var initial_pop_scope = birth_chance.selectors[i][0];
          var local_value = birth_chance.selectors[i][1]*birth_scalar;

          var local_pop_scope = module.exports.multiplyPops(initial_pop_scope, birth_scalar*local_value, true); //Using this instead of createPops() for more standardisation
          var population_change = Math.ceil(local_pop_scope.size*birth_scalar*local_value);

          //Add to b_ tag; replace local_pop_scope
          modifyValue(province_obj.pops, `b_${current_year}`, population_change);

          //[REVISIT] - Statistical compounding on iterative variable subset theory ops is probably an inevitability unless you can work out the completeness of some NP-HARD maths theorem, Aust. Doing this for now - Vis
          var all_local_tags = Object.keys(local_pop_scope.tags);

          //Override tags
          for (var x = 0; x < all_local_tags.length; x++)
            province_obj.pops[all_local_tags[x]] = local_pop_scope.tags[all_local_tags[x]];
        }
      }

      //Death handling
      {
        //Fetch death pop scope arguments for accurate age distribution

        //Fetch death_chance
        var death_chance = parsePopLimit(config.deaths, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Iterate over death_chance.selectors
        for (var i = 0; i < death_chance.selectors.length; i++) {
          var initial_pop_scope = death_chance.selectors[i][0];
          var local_value = death_chance.selectors[i][1];

          local_pop_scope = module.exports.multiplyPops(initial_pop_scope, local_value);

          //Remove pops
          module.exports.removePop(user_id, {
            amount: local_pop_scope.size,
            pop_scope: local_pop_scope
          });
        }
      }
    }

    //Pop Job Seeking and Employment
    {
      if (province_obj.buildings) {
        //Fetch remaining open positions
        var open_positions = 0;
        var total_job_seekers = 0;
        var unemployed_pops = module.exports.getUnemployedPops(province_id, pop_type);

        for (var i = 0; i < province_obj.buildings.length; i++) {
          var local_building = province_obj.buildings[i];

          open_positions += returnSafeNumber(local_building[`${pop_type}_positions`]);
        }

        //Remove unemployed_pops from open_positions
        open_positions -= unemployed_pops;

        //Iterate over province_obj.buildings and if the wages are now below current_median, pop types should seek new jobs if higher positions exist
        if (open_positions > 0)
          for (var i = 0; i < province_obj.buildings.length; i++) {
            var local_building = province_obj.buildings[i];

            if (local_building.employment)
              if (local_building[`${pop_type}_wage`]) {
                var current_wage = local_building[`${pop_type}_wage`];

                if (current_wage < current_median) {
                  var new_job_seekers = 1 - (current_wage/current_median);
                  new_job_seekers = Math.min(new_job_seekers, open_positions);

                  total_job_seekers += new_job_seekers;
                  layoffWorkers(local_building, pop_type, new_job_seekers);
                }
              }
          }

        //Process final employment both for those unemployed and those seeking a better job
        module.exports.processEmployment(province_id, pop_type, {
          sorted_wage_obj: options.sorted_wage_obj,
          unemployed_pops: unemployed_pops
        });
      }
    }

    //Pop Migration
    {
      if (all_internal_provinces.length > 0) {
        //Get internal migration chance
        var internal_migration_chance = parsePopLimit(config.pop_migration.internal_emigration, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Apply internal migration to various pop scopes /2
        var internal_migration_scope = {};
        var internal_migration_scopes = [];

        for (var i = 0; i < internal_migration_chance.selectors.length; i++) {
          var local_value = internal_migration_chance.selectors[i];

          if (local_value[1] >= 0) {
            var local_chance = local_value[1]/2;
            var local_pop_scope = multiplyPops(local_value[0], local_chance);

            internal_migration_scopes.push(local_pop_scope);
          }
        }

        if (internal_migration_scopes.length > 0) {
          internal_migration_scope = internal_migration_scopes[0];

          if (internal_migration_scopes.length > 1)
            for (var i = 1; i < internal_migration_scopes.length; i++)
              internal_migration_scope = module.exports.addPopScopes(internal_migration_scope, internal_migration_scopes[i]);

          //internal_migration_scopes is now the total amount of people that want to move out, transfer pops proportionally to internal provinces
          if (internal_migration_scope.size)
            for (var i = 0; i < all_internal_provinces.length; i++) {
              var local_value = internal_migration_table[all_internal_provinces[i]];
              var move_out_scope = module.exports.multiplyPops(internal_migration_scope, local_value);

              module.exports.movePops(province_obj.id, move_out_scope, all_internal_provinces[i]);
            }
        }
      }

      if (all_external_provinces.length > 0) {
        //Get external migration chance
        var external_migration_chance = parsePopLimit(config.pop_migration.external_emigration, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Apply external migration to various pop scopes /2 [WIP] - REVISIT LOGIC TO ACCOUNT FOR NATION SELECTION
        var external_migration_scope = {};
        var external_migration_scopes = [];

        for (var i = 0; i < external_migration_chance.selectors.length; i++) {
          var local_value = external_migration_chance.selectors[i];

          if (local_value[1] >= 0) {
            var local_chance = local_value[1]/2;
            var local_pop_scope = module.exports.multiplyPops(local_value[0], local_chance);

            external_migration_scopes.push(local_pop_scope);
          }
        }

        if (external_migration_scopes.length > 0) {
          external_migration_scope = external_migration_scopes[0];

          if (external_migration_scopes.length > 1)
            for (var i = 1; i < external_migration_scopes.length; i++)
              external_migration_scope = module.exports.addPopScopes(external_migration_scope, external_migration_scopes[i]);

          //external_migration_scopes is now the total amount of people that want to move out, transfer pops proportionally to external provinces
          if (external_migration_scope.size)
            for (var i = 0; i < all_external_provinces.length; x++) {
              var local_value = external_migration_table[all_external_provinces[i]];
              var move_out_scope = module.exports.multiplyPops(external_migration_scope, external_migration_scopes[i]);

              module.exports.movePops(province_obj.id, move_out_scope, all_external_provinces[i]);
            }
        }
      }
    }

    //Pop Promotion/Demotion - [WIP] - Make it so that promotion/demotion can occur between classes if promotion/demotion is otherwise unspecified.
    if (pop_scope.size > 0) {
      //Pop demotion
      var pop_demotion_selectors = parsePopLimit(config.pop_mobility.demotion, {
        province_id: province_id,
        pop_type: pop_type,
        pop_scope: pop_scope
      });

      if (pop_demotion_selectors.boolean) {
        //pop_demotion_selectors.selectors - [pop_scope, value];
        for (var i = 0; i < pop_demotion_selectors.selectors.length; i++) {
          var local_pop_scope = pop_demotion_selectors.selectors[i][0];
          var local_value = pop_demotion_selectors.selectors[i][1];

          var all_local_tags = Object.keys(local_pop_scope.tags);

          if (has_demotes) {
            var all_demotes = Object.keys(config_obj.demotes_to);
            var demote_chances = {};

            for (var x = 0; x < all_demotes.length; x++)
              if (config.pops[all_demotes[x]]) { //Revamp to standardise percentage of config_obj.demotes_to to one another; calculate chances for all and standardise to 100%; apply to local_pop_scope
                var local_pop_demote_chance = parsePopLimit(config_obj.demotes_to[all_demotes[x]], {
                  province_id: province_id,
                  pop_type: pop_type,
                  pop_scope: pop_demotion_selectors.pop_scope
                });
                var weighted_total = 0;

                //Fetch weighted_total
                if (local_pop_demote_chance.boolean) {
                  for (var y = 0; y < local_pop_demote_chance.selectors.length; y++)
                    weighted_total += local_pop_demote_chance.selectors[y][0].size*
                      local_pop_demote_chance.selectors[y][1];

                  //Add weighted_total to demote_chances
                  modifyValue(demote_chances, all_demotes[x], weighted_total, true);
                }
              }

            //Standardise percentage for demote_chances; iterate over all of them and demote to respective pops
            demote_chances = standardisePercentage(demote_chances);

            var all_demote_chances = Object.keys(demote_chances);

            for (var x = 0; x < all_demote_chances.length; x++) {
              var local_percentage = demote_chances[all_demote_chances[x]];

              var local_demote_amount = Math.floor(returnSafeNumber(local_pop_scope[pop_type])*local_value*local_percentage);
              var local_used_demote = Math.floor(returnSafeNumber(local_pop_scope[`used_${pop_type}`])*local_value*local_percentage);

              //Layoff from wealth pools
              for (var y = 0; y < all_local_tags.length; y++)
                if (all_local_tags.startsWith("wealth-")) {
                  var local_layoff_amount = local_pop_scope.tags[all_local_tags[y]]*local_value*local_percentage;
                  var split_wealth_key = all_local_tags[y].split("-");

                  var local_building = building_map[split_wealth_key[1]];

                  layoffWorkers(local_building, split_wealth_key[2], local_layoff_amount);
                }

              //Add to chosen profession
              modifyValue(province_obj.pops, pop_type, local_demote_amount*-1, true);
              modifyValue(province_obj.pops, pop_type, `used_${pop_type}`, local_used_demote*-1, true);
              modifyValue(province_obj.pops, all_demote_chances[x], local_demote_amount);

              //Set province tracker
              province_obj.trackers[`demote-${pop_type}-${all_demote_chances[x]}`] = local_demote_amount;
            }
          }
        }
      }

      //Pop promotion
      var pop_promotion_selectors = parsePopLimit(config.pop_mobility.promotion, {
        province_id: province_id,
        pop_type: pop_type,
        pop_scope: pop_scope
      });

      if (pop_promotion_selectors.boolean) {
        //pop_promotion_selectors.selectors - [pop_scope, value];
        for (var i = 0; i < pop_promotion_selectors.length; i++) {
          var local_pop_scope = pop_promotion_selectors.selectors[i][0];
          var local_value = pop_demotion_selectors.selectors[i][1];

          var all_local_tags = Object.keys(local_pop_scope.tags);

          if (has_promotes) {
            var all_promotes = Object.keys(config_obj.promotes_to);
            var promote_chances = {};

            for (var x = 0; x < all_promotes.length; x++)
              if (config.pops[all_promotes[x]]) {
                var local_pop_promote_chance = parsePopLimit(config_obj.promotes_to[all_promotes[x]], {
                  province_id: province_id,
                  pop_type: pop_type,
                  pop_scope: pop_promotion_selectors.pop_scope
                });
                var weighted_total = 0;

                //Fetch weighted_total
                if (local_pop_promote_chance.boolean)
                  for (var y = 0; y < local_pop_promote_chance.selectors.length; y++)
                    weighted_total += local_pop_promote_chance.selectors[y][0].size*local_pop_promote_chance.selectors[y][1];

                //Add weighted_total to promote_chances
                modifyValue(promote_chances, all_promotes[x], weighted_total, true);
              }

            //Standardise percentage for promote_chances; iterate over all of them and promote to respective pops
            promote_chances = standardisePercentage(promote_chances);

            var all_promote_chances = Object.keys(promote_chances);

            for (var x = 0; x < all_promote_chances.length; x++) {
              var local_percentage = promtoe_chances[all_promote_chances[x]];

              var local_promote_amount = Math.floor(returnSafeNumber(local_pop_scope[pop_type])*local_value*local_percentage);
              var local_used_promote = Math.floor(returnSafeNumber(local_pop_scope[`used_${pop_type}`])*local_value*local_percentage);

              //Layoff from wealth pools
              for (var y = 0; y < all_local_tags.length; y++)
                if (all_local_tags.startsWith("wealth-")) {
                  var local_layoff_amount = local_pop_scope.tags[all_local_tags[y]]*local_value*local_percentage;
                  var split_wealth_key = all_local_tags[y].split("-");

                  var local_building = building_map[split_wealth_key[1]];

                  layoffWorkers(local_building, split_wealth_key[2], local_layoff_amount);
                }

              //Add to chosen profession
              modifyValue(province_obj.pops, pop_type, local_promote_amount*-1, true);
              modifyValue(province_obj.pops, pop_type, `used_${pop_type}`, local_used_promote*-1, true);
              modifyValue(province_obj.pops, all_promote_chances[x], local_promote_amount);

              //Set province tracker
              province_obj.trackers[`promote-${pop_type}-${all_promote_chances[x]}`] = local_promote_amount;
            }
          }
        }
      }
    }
  },

  processPurchases: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var province_obj = main.provinces[province_id];

    if (province_obj)
      if (province_obj.pops) {
        var all_good_categories = Object.keys(config.defines.economy.good_categories);
        var all_pop_keys = Object.keys(province_obj.pops);

        //Iterate through all_pop_keys for wealth- starting keys
        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("wealth-")) {
            var current_allowance;
            var current_allowance_percentage;
            var local_percentage = local_wealth_pool.size/100000;
            var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
            var spent_wealth = 0;
            var split_key = all_pop_keys[i].split("-");
            var pop_type = split_key[2];

            var pop_obj = config.pops[pop_type];

            //Initialise received_goods scope
            local_wealth_pool.received_goods = {};

            //Check pop_obj.per_100k.needs
            if (pop_obj.per_100k)
              if (pop_obj.per_100k.needs) {
                var category_buy_order = pop_obj.buy_order;
                var total_fulfilment = 0;
                var total_variety = 0;

                for (var x = 0; x < category_buy_order.length; x++)
                  local_wealth_pool.received_goods[category_buy_order[x]] = {};

                for (var x = 0; x < all_good_categories.length; x++) {
                  var local_good_category = config.defines.economy.good_categories[all_good_categories[x]];
                  current_allowance_percentage = returnSafeNumber(local_good_category.importance, 1);
                  current_allowance = local_wealth_pool.income*current_allowance_percentage;

                  //Iterate over category_buy_order and local needs groups to buy everything in lookup.goods_type[all_good_categories[x]]
                  for (var y = 0; y < category_buy_order.length; y++) {
                    var local_buy_order = pop_obj[`${category_buy_order[y]}-buy_order`];
                    var local_category = pop_obj.per_100k.needs[category_buy_order[y]];
                    var local_received_goods = local_wealth_pool.received_goods[category_buy_order[y]];

                    for (var z = 0; z < local_buy_order.length; z++)
                      if (spent_wealth < local_wealth_pool.income) {
                        //Begin buying as many goods as needed for this wealth pool size
                        var local_market_good = main.market[local_buy_order[z]]
                        var local_value = local_category[local_buy_order[z]];

                        //Spend money on good
                        if (local_market_good) {
                          var local_need = Math.ceil(local_value*local_percentage);

                          var actual_consumption = Math.min(getGoodAmount(user_id, local_buy_order[z]), local_need);
                          var local_worth = actual_consumption*local_market_good.buy_price;
                          var local_tax = local_worth*returnSafeNumber(usr[`${pop_obj.class}-duties_tax`]);
                          var market_consumption = Math.ceil(actual_consumption*config.defines.economy.resource_production_scalar);

                          //World Market processing
                          local_market_good.demand += market_consumption;
                          local_market_good.stock -= market_consumption;

                          if (local_market_good.stock < 1)
                            local_market_good.stock = 1;

                          spent_wealth += (local_worth + local_tax);
                          modifyValue(local_received_goods, local_buy_order[z], actual_consumption);
                          modifyValue(usr.trackers.tax, `${pop_obj.class}-duties_tax`, local_tax);
                        }
                      }
                  }
                }

                //Subtract spent_wealth from wealth pool
                local_wealth_pool.wealth -= spent_wealth;
                local_wealth_pool.spending = spent_wealth;

                //Update _fulfilment and _variety for each category
                for (var x = 0; x < category_buy_order.length; x++) {
                  var local_received_goods = local_wealth_pool.received_goods[category_buy_order[x]];

                  var local_fulfilment_obj = module.exports.getPopNeedsFulfilment(local_received_goods, pop_type, local_wealth_pool.size, {
                    needs_category: category_buy_order[x],
                    return_object: true
                  });
                  total_fulfilment += local_fulfilment_obj.fulfilment;
                  total_variety += local_fulfilment_obj.variety;

                  //Set local fulfilment and variety
                  local_wealth_pool[`${category_buy_order[x]}-fulfilment`] = local_fulfilment_obj.fulfilment;
                  local_wealth_pool[`${category_buy_order[x]}-variety`] = local_fulfilment_obj.variety;
                }

                //Set general fulfilment and variety
                local_wealth_pool.fulfilment = total_fulfilment/category_buy_order.length;
                local_wealth_pool.variety = total_variety/category_buy_order.length;
              }
          }
      }
  },

  //processPops() - Processes all pops in a given province
  processPops: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var province_obj = main.provinces[province_id];
    var user_id = province_obj.controller;
    var usr = main.users[user_id];

    //Iterate over all pops and process them
    for (var i = 0; i < all_pops.length; i++) {
      //Initialise local tracker variables
      var local_sorted_wages = getBuildingWages(province_id, all_pops[i]);
      var median_wage = getMedianWage(province_id, {
        pop_type: all_pops[i],
        building_wage_obj: local_sorted_wages
      });

      //Set trackers
      province_obj.births = module.exports.getProvinceBirthRate(user_id, province_id);
      province_obj[`${all_pops[i]}_median_wage`] = median_wage;

      //Pop processing
      processPop(province_id, all_pops[i], {
        sorted_wage_obj: local_sorted_wages
      });

      //Kill off anyone over old-age upper bound
      var over_upper_bound = module.exports.selectPops({
        province_id: province_id,
        age: {
          min: config.defines.economy.old_age_hard_upper_bound,
          max: 1000
        }
      });
      module.exports.removePop(user_id, {
        amount: over_upper_bound.size,
        pop_scope: over_upper_bound
      });
    }
  },

  /*
    removePop() - Removes pops from a province
    options: See selectPops(), additional options: {
      amount: 50000, - The amount of pops to remove.
      province_id: "5707", - The province ID to remove pops from.
      pop_scope: {} - Optional. The pop scope to pass to the argument
    }
  */
  removePop: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Initialise undeclared options
    if (!options.province_id)
      if (options.pop_scope)
        options.province_id = options.pop_scope.province_id;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var killed = 0;
    var pop_scope = (!options.pop_scope) ? module.exports.selectPops(options) : options.pop_scope;
    var province_obj = main.provinces[options.province_id];
    var usr = main.users[actual_id];

    //Subtract population
    if (province_obj) {
      var building_key_map = (options.building_key_map) ? options.building_key_map : getBuildingMap(options.province_id);

      if (pop_scope.size > 0) {
        var all_tags = Object.keys(pop_scope.tags);
        var scalar = 1;

        if (options.amount < pop_scope.size)
          scalar = options.amount/pop_scope.size;

        //Remove all tags; lay off those in wealth pools
        for (var i = 0; i < all_tags.length; i++) {
          var local_value = Math.floor(pop_scope.tags[all_tags[i]]*scalar);

          if (all_tags[i].startsWith("wealth-")) {
            var split_key = all_tags[i].split("-");

            var building_id = split_key[1];
            var local_building = province_obj.buildings[building_key_map[building_id]];
            var local_pop_type = split_key[2];

            if (local_building)
              layoffWorkers(local_building, local_pop_type, local_value);
          } else {
            modifyValue(province_obj.pops, all_tags[i], local_value*-1, true);
          }
        }

        //Set killed
        killed = Math.floor(scalar*pop_scope.size);
      }

      if (options.pop_type)
        if (!province_obj.pops[options.pop_type])
          province_obj.pops[options.pop_type] = 0;
      if (!province_obj.pops.population)
        province_obj.pops.population = 0;
    }

    //Return statement
    return killed;
  },

  /*
    removePops() - Kills a certain number of pops from a user based on the available options.
    options: {
      migration: true/false, - Whether the pops migrated or not instead of being killed. False by default
      options: {}, - Options for pop scope. Optional.
      provinces: ["6709", "6710"], - A list of provinces to target for removing pops. All of a user's provinces by default
      type: "soldiers", - Which type of pop to kill off
      amount: 10000 - How much of the pop to kill off
    }
  */
  removePops: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var decimation_obj = {};
    var economy_defines = config.defines.economy;
    options.type = (options.type) ?
      getList(options.type) : Object.keys(config.pops);
    var province_pop_scope_map = {};
    var remaining_population = returnSafeNumber(options.amount);
    var usr = main.users[actual_id];

    var decimation_array = splitNumber(1, options.type.length);
    var target_provinces = (options.provinces) ?
      getList(options.provinces) : shuffleArray(getProvinces(user_id, { return_keys: true }));

    //Initialise decimation_obj
    for (var i = 0; i < options.type.length; i++)
      decimation_obj[options.type[i]] = decimation_array[i];

    //Fetch total applicable pops over all target_provinces, options.amount/total_applicable_pops = % to remove from each province
    var local_options = {};
    var total_applicable_pops = 0;

    //Initialise local_options
    {
      local_options.pop_types = options.type;

      //Age handling
      {
        var has_age_argument = false;

        if (options.options)
          if (options.options.age)
            has_age_argument = true;

        if (!has_age_argument) {
          var is_only_military_pops = true;

          for (var i = 0; i < options.type.length; i++)
            if (!config.pops[options.type[i]].military_pop)
              is_only_military_pops = false;

          if (is_only_military_pops)
            local_options.age = {
              min: economy_defines.soldier_age_lower_bound,
              max: economy_defines.soldier_age_upper_bound,
              mean: Math.floor((economy_defines.soldier_age_lower_bound + economy_defines.soldier_age_upper_bound)/2)
            };
        }
      }

      if (options.options)
        local_options = mergeObjects(local_options, options.options);
    }

    //Iterate over all target_provinces using selectPops() scope
    for (var i = 0; i < target_provinces.length; i++) {
      //Deep copy local_options to new_options and set province_id
      var new_options = JSON.parse(JSON.stringify(local_options));
      new_options.province_id = target_provinces[i];

      var local_pop_scope = module.exports.selectPops(new_options);
      total_applicable_pops += local_pop_scope.size;
      province_pop_scope_map[new_options.province_id] = local_pop_scope;
    }

    //Remove pops from target_provinces based on scalar of options.amount/total_applicable_pops
    var kill_scalar = options.amount/total_applicable_pops;
    var soldiers_killed = 0;
    var total_removed = 0;

    for (var i = 0; i < target_provinces.length; i++) {
      var local_pop_scope = province_pop_scope_map[target_provinces[i]];

      total_removed += module.exports.removePop(user_id, {
        amount: Math.ceil(kill_scalar*local_pop_scope.size),
        province_id: target_provinces[i],
        pop_scope: local_pop_scope
      });

      for (var x = 0; x < options.type.length; x++) {
        var config_obj = config.pops[options.type[x]];

        if (config_obj.military_pop)
          soldiers_killed += returnSafeNumber(local_pop_scope[options.type[x]]);
      }
    }

    //Add to civilian/military casualties tracker
    if (!options.migration) {
      usr.recent_military_casualties[usr.recent_military_casualties.length - 1] += soldiers_killed;
      usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += Math.max(total_removed - soldiers_killed, 0);
    }

    //Return statement
    return total_removed;
  },

  /*
    selectPops() - Merges pops based on a pop's characteristics and given frequency distributions according to proportionality.
    options: {
      province_id: "4707", - The province ID to merge pops from. Optional with pop_scope as an additional option
      pop_scope: {}, - The pop scope to provide to get a subset of

      age: { - Optional. Undefined by default
        min: 20,
        max: 35,
        mean: 25 - Optional. Midpoint by default
      },
      age: 47, - Optional. Number argument. Overrides top argument.
      building_ids: [], - A given list of building ID's to select employed pops from
      culture: [], - A list of culture IDs that should be scoped to
      education_level: { - Optional. Undefined by default
        min: 0,
        max: 1,
        mean: 0.50 - Optional. Midpoint by default
      },
      education_level_less_than: 0.50, - Optional. Undefined by default.
      employed: true/false, - Optional. Whether the pop is employed or not. False by default
      empty: true/false, - Optional. Whether to return an empty pop scope. False by default
      has_accepted_culture: true/false, - Optional. Restricts pops to accepted cultures only
      has_<goods_category>: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      has_<goods_category>_less_than: 0.80, - Optional. Numeric percentage. Undefined by default
      has_<goods_category>_variety: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      has_<goods_category>_variety_less_than: 0.90, - Optional. Undefined by default
      homeless: true/false, - Optional. Whether the pop is currently homeless. Undefined by default
      income: 500, - Optional. What income levels should be targeted in scope. Undefined by default
      income_less_than: 250, - Optional. What income levels should be targeted in scope. Undefined by default
      is_employed: true/false, - Optional. Whether the pop should be employed or not. Undefined by default
      pop_types: [], - A given list of pop types to return a single pop from. Returns all pops by default
      wealth: 40000, - Optional. What their wealth should be above or equal to
      wealth_less_than: 20000 - Optional. What their wealth should be below or equal to
    }

    Returns: {
      size: 4407, - The size of the pop that meets the aforementioned categories
      income: 0, - Their relative income last turn. All metrics given in weighted averages
      wealth: 0, - Their current wealth

      staple_goods-fulfilment: 0.86, - Category specific fulfilment and variety
      staple_goods-variety: 0.60,
      ..

      fulfilment: 0.67, - General fulfilment and variety
      variety: 0.15,
      ..

      //Key-value pairings that would be selected from this merge pop scope
      tags: {
        labourers: 4407,
        engineers: 2202,
        used_engineers: 1105,
        ..

        wealth-<building_id>-<pop_type>: 2505
      }
    }
  */
  selectPops: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var current_scope = {
      size: 0,
      income: 0,
      wealth: 0,

      tags: {}
    };
    var province_id = (options.pop_scope) ? options.pop_scope.province_id : options.province_id;
    var province_obj = main.provinces[province_id];

    //Initialise options
    if (!options.pop_types) options.pop_types = Object.keys(config.pops);

    //Declare local instance variables
    var all_options = Object.keys(options);

    //Declare pop categories
    var age_tags = {};
    var culture_tags = {};
    var education_level_tags = {};
    var employed_tags = {}; //Differential boolean with is_unemployed
    var homeless_amount = 0; //Boolean with housed_amount
    var housed_amount = 0; //Boolean with homeless_amount
    var is_unemployed = 0; //Differential boolean with employed_tags
    var pop_type_tags = {};
    var wealth_pool_tags = {};

    //Trackers for internal purposes
    var total_employed = 0;
    var total_fulfilment = {};
    var total_general_fulfilment = 0;
    var total_general_variety = 0;
    var total_income = 0;
    var total_variety = {};
    var total_wealth = 0;
    var total_wealth_pools = 0;

    //Check if province even has pops
    if (province_obj.pops) {
      var all_pop_keys = Object.keys(province_obj.pops);

      //Parse superobjects first, such as wealth pools
      for (var i = 0; i < all_pop_keys.length; i++) {
        var local_value = province_obj.pops[all_pop_keys[i]];

        if (typeof local_value == "object")
          if (all_pop_keys[i].startsWith("wealth-")) {
            var all_conditions_met = true;
            var all_wealth_keys = Object.keys(local_value);
            var split_key = all_pop_keys[i].split("-");

            var building_id = split_key[1];
            var local_pop_type = split_key[2];

            //Building ID handler
            if (options.building_ids)
              if (!options.building_ids.includes(building_id))
                all_conditions_met = false;

            //Employed handler
            if (options.is_employed == false)
              all_conditions_met = false;

            //Goods category fulfilment handler; Goods category variety handler
            for (var x = 0; x < all_options.length; x++) {
              //has_<goods_category>
              if (all_options[x].startsWith("has_")) {
                var local_goods_category = all_options[x].replace("has_", "");

                if (local_value[`${local_goods_category}-fulfilment`] < options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_less_than
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_less_than")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_less_than", "");

                if (local_value[`${local_goods_category}-fulfilment`] >= options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_variety
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_variety")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_variety", "");

                if (local_value[`${local_goods_category}-variety`] < options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_variety_less_than
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_variety_less_than")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_variety_less_than", "");

                if (local_value[`${local_goods_category}-variety`] >= options[all_options[x]])
                  all_conditions_met = false;
              }
            }

            //Income handler
            var actual_income = local_value.income/local_value.size;

            if (options.income)
              if (actual_income < options.income)
                all_conditions_met = false;

            if (options.income_less_than)
              if (actual_income >= options.income_less_than)
                all_conditions_met = false;

            //Pop type handler
            if (!options.pop_types.includes(local_pop_type))
              all_conditions_met = false;

            //Wealth handler
            var actual_wealth = local_value.wealth/local_value.size;

            if (options.wealth)
              if (actual_wealth < options.wealth)
                all_conditions_met = false;

            if (options.wealth_less_than)
              if (actual_wealth >= options.wealth_less_than)
                all_conditions_met = false;

            //Append to wealth_pool_tags if all_conditions_met
            if (all_conditions_met) {
              modifyValue(employed_tags, `used_${local_pop_type}`, local_value.size);
              modifyValue(wealth_pool_tags, all_pop_keys[i], local_value.size);

              //total_fulfilment, total_variety handler
              for (var x = 0; x < all_wealth_keys.length; x++) {
                var local_pool_value = local_value[all_wealth_keys[x]];

                if (all_wealth_keys[x].endsWith("-fulfilment")) {
                  modifyValue(total_fulfilment, all_wealth_keys[x], local_pool_value);
                } else if (all_wealth_keys[x].endsWith("-variety")) {
                  modifyValue(total_variety, all_wealth_keys[x], local_pool_value);
                }
              }

              total_general_fulfilment += returnSafeNumber(local_value.fulfilment);
              total_general_variety += returnSafeNumber(local_value.variety);

              //.income, .wealth handler
              total_income += actual_income;
              total_wealth += actual_wealth;
              total_wealth_pools++;
            }
          }
      }

      //Parse Pearson objects next
      {
        //Age handler
        if (typeof options.age == "object") {
          var max = returnSafeNumber(options.age.max, config.defines.economy.old_age_hard_upper_bound);
          var min = returnSafeNumber(options.age.min, 0);

          if (!options.age.mean) { //Block select
            for (var i = 0; i < all_pop_keys.length; i++) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              if (all_pop_keys[i].startsWith("b_")) {
                var birth_year = parseInt(all_pop_keys[i].replace("b_", ""));
                var current_age = Math.floor(main.date.year - birth_year);

                if (current_age >= min && current_age <= max)
                  modifyValue(age_tags, all_pop_keys[i], local_value);
              }
            }
          } else { //Skewed pearson object
            var mean = returnSafeNumber(options.age.mean);

            var age_distribution = pearsonVIIDistribution(max, mean, min, max);
            var all_age_distribution_keys = Object.keys(age_distribution);

            for (var i = 0; i < all_age_distribution_keys.length; i++) {
              var local_birth_year = Math.floor(main.date.year - parseInt(all_age_distribution_keys[i]));
              var local_percentage = age_distribution[all_age_distribution_keys[i]];
              var local_value = Math.floor(returnSafeNumber(province_obj.pops[`b_${local_birth_year}`])*local_percentage);

              modifyValue(age_tags, `b_${local_birth_year}`, local_value);
            }
          }
        }

        //Education level handler
        if (typeof options.education_level == "object") {
          var max = returnSafeNumber(options.education_level.max, 1);
          var min = returnSafeNumber(options.education_level.min, 0);

          if (!options.education_level.mean) {
            for (var i = 0; i < all_pop_keys.length; i++) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              if (all_pop_keys[i].startsWith("el_")) {
                var education_level = parseInt(local_value.replace("el_", ""));

                if (education_level >= min*100 && education_level <= max*100)
                  modifyValue(education_level_tags, `el_${education_level}`, local_value);
              }
            }
          } else {
            var mean = returnSafeNumber(options.education_level.mean);

            var education_distribution = pearsonVIIDistribution(100, mean, min, max, {
              key_name: "el"
            });
            var all_education_distribution_keys = Object.keys(education_distribution);

            for (var i = 0; i < all_education_distribution_keys.length; i++) {
              var local_amount = education_distribution[all_education_distribution_keys[i]];
              var local_education_amount = returnSafeNumber(province_obj.pops[all_education_distribution_keys[i]]);
              var local_value = local_education_amount*local_amount;

              modifyValue(education_level_tags, all_education_distribution_keys[i], local_value);
            }
          }
        }
      }

      //Parse simple tag pop categories next
      for (var i = 0; i < all_pop_keys.length; i++) {
        var local_value = province_obj.pops[all_pop_keys[i]];

        if (typeof local_value != "object") {
          //Culture handler
          if (options.culture)
            if (all_pop_keys[i].startsWith("culture-")) {
              var culture_id = all_pop_keys[i].replace("culture-", "");

              if (options.culture.includes(culture_id))
                modifyValue(culture_tags, all_pop_keys[i], local_value);
            }

          //Pop type handler
          if (config.pops[all_pop_keys[i]])
            if (options.pop_types.includes(all_pop_keys[i]))
              modifyValue(pop_type_tags, all_pop_keys[i], local_value);
        }
      }

      //Non-iterative boolean pop categories
      {
        //Homeless handler
        homeless_amount = province_obj.pops.population - returnSafeNumber(province_obj.housing);

        //Housed handler
        housed_amount = province_obj.pops.population - homeless_amount;

        //Unemployed handler
        {
          if (options.is_employed != undefined) {

            for (var i = 0; i < options.pop_types.length; i++)
              total_employed += returnSafeNumber(province_obj.pops[`used_${options.pop_types[i]}`]);

            is_unemployed = province_obj.pops.population - total_employed;
          }
        }
      }

      //Fetch the total % of province population that is an intersection of the pop category tags defined above by multiplying category_sum/province_population together. Only those specified in options should be applicable. See Belgian Workers problem for more information.

      //Note that wealth superobjects are scaled to total_employed and not province_obj.pops.population

      var hard_specified_categories = [];
      var hard_specified_tags = {}; //Hard specified tags are just anything that has Object.keys().length > 0
      var pop_scalar = 1; //Multiplied iteratively by each consecutive category; then all other pop tags in the province not hard specified are multiplied by this to fetch final .tags result

      {
        //Age handler
        if (Object.keys(age_tags).length > 0) {
          hard_specified_tags = mergeObjects(age_tags, hard_specified_tags);
          var local_scalar = getObjectSum(age_tags)/province_obj.pops.population;

          pop_scalar = pop_scalar*local_scalar;
          hard_specified_categories.push("age");
        }

        //Culture handler
        if (Object.keys(culture_tags).length > 0) {
          hard_specified_tags = mergeObjects(culture_tags, hard_specified_tags);
          var local_scalar = getObjectSum(culture_tags)/province_obj.pops.population;

          pop_scalar = pop_scalar*local_scalar;
          hard_specified_categories.push("culture");
        }

        //Education level handler
        if (Object.keys(education_level_tags).length > 0) {
          hard_specified_tags = mergeObjects(education_level_tags, hard_specified_tags);
          var local_scalar = getObjectSum(education_level_tags)/province_obj.pops.population;

          pop_scalar = pop_scalar*local_scalar;
          hard_specified_categories.push("education");
        }

        //Employed handler; Unemployed handler
        if (options.is_employed != undefined) {
          if (options.is_employed == true) {
            pop_scalar = pop_scalar*(is_unemployed/province_obj.pops.population);
          } else if (options.is_employed == false) {
            pop_scalar = pop_scalar*(total_employed/province_obj.pops.population);
          }

          hard_specified_categories.push("is_employed");
        }

        //Homeless handler; Housed handler - Boolean
        if (options.homeless != undefined) {
          if (options.homeless == true) {
            pop_scalar = pop_scalar*(homeless_amount/province_obj.pops.population);
          } else if (options.homeless == false) {
            pop_scalar = pop_scalar*(housed_amount/province_obj.pops.population);
          }

          hard_specified_categories.push("homeless");
        }

        //Pop type handler
        if (Object.keys(pop_type_tags).length > 0) {
          hard_specified_tags = mergeObjects(pop_type_tags, hard_specified_tags);
          var local_scalar = getObjectSum(pop_type_tags)/province_obj.pops.population;

          pop_scalar = pop_scalar*local_scalar;
          hard_specified_categories.push("pop_types");
        }

        //Wealth pool handler - Superobject; scaled to total_employed
        if (Object.keys(wealth_pool_tags).length > 0) {
          hard_specified_tags = mergeObjects(wealth_pool_tags, hard_specified_tags);
          var local_scalar = getObjectSum(wealth_pool_tags)/province_obj.pops.population;

          pop_scalar = pop_scalar*local_scalar;
          hard_specified_categories.push("wealth");
        }

        //Merge hard_specified_tags with current_scope.tags
        current_scope.tags = mergeObjects(hard_specified_tags, current_scope.tags);
      }
    }

    //Multiply remaining unaccounted province tags by pop_scalar and merge to current_scope.tags (floored)
    var soft_specified_tags = {};

    //Initialise soft_specified_tags
    {
      for (var i = 0; i < all_pop_keys.length; i++)
        if (hard_specified_tags[all_pop_keys[i]] == undefined) {
          var is_hard_specified = false;
          var local_value = province_obj.pops[all_pop_keys[i]];

          //Number/object handler
          if (typeof local_value == "number") {
            //Make sure value is not in hard_specified_categories; inverse qualification theorem
            {
              //Age handler
              if (hard_specified_categories.includes("age"))
                if (all_pop_keys[i].startsWith("b_"))
                  is_hard_specified = true;

              //Culture handler
              if (hard_specified_categories.includes("culture"))
                if (all_pop_keys[i].startsWith("culture-"))
                  is_hard_specified = true;

              //Education level handler
              if (hard_specified_categories.includes("education"))
                if (all_pop_keys[i].startsWith("el_"))
                  is_hard_specified = true;

              //Employed handler; Unemployed handler
              if (hard_specified_categories.includes("is_employed"))
                if (all_pop_keys[i].startsWith("used_"))
                  is_hard_specified = true; //This is already handled in wealth_pool_tags

              //Pop type handler
              if (hard_specified_categories.includes("pop_types"))
                if (config.pops[all_pop_keys[i]])
                  is_hard_specified = true;
            }

            if (!is_hard_specified)
              modifyValue(soft_specified_tags, all_pop_keys[i], Math.floor(local_value*pop_scalar));
          } else if (typeof local_value == "object") {
            //Only valid if no wealth_pool_tags are found
            if (Object.keys(wealth_pool_tags).length == 0)
              //Check if local_value is wealth pool
              if (all_pop_keys[i].startsWith("wealth-")) {
                var split_key = all_pop_keys[i].split("-");

                //Push to soft_specified_tags
                modifyValue(soft_specified_tags, all_pop_keys[i], Math.floor(local_value.size*pop_scalar));
              }
          }
        }
    }

    //Merge soft_specified_tags with current_scope.tags
    current_scope.tags = mergeObjects(soft_specified_tags, current_scope.tags);

    //Set .income, .wealth
    current_scope.income = returnSafeNumber(Math.ceil(total_income/total_wealth_pools));
    current_scope.wealth = returnSafeNumber(Math.ceil(total_wealth/total_wealth_pools));
    current_scope.size = Math.ceil(province_obj.pops.population*pop_scalar);

    //Set fulfilment, variety tags
    var all_fulfilment_keys = Object.keys(total_fulfilment);
    var all_variety_keys = Object.keys(total_variety);

    for (var i = 0; i < all_fulfilment_keys.length; i++) {
      var local_value = total_fulfilment[all_fulfilment_keys[i]];

      total_fulfilment[all_fulfilment_keys[i]] = local_value/total_wealth_pools;
    }
    for (var i = 0; i < all_variety_keys.length; i++) {
      var local_value = total_variety[all_variety_keys[i]];

      total_variety[all_variety_keys[i]] = local_value/total_wealth_pools;
    }

    current_scope = mergeObjects(current_scope, total_fulfilment);
    current_scope = mergeObjects(current_scope, total_variety);

    current_scope.fulfilment = returnSafeNumber(total_general_fulfilment/total_wealth_pools);
    current_scope.variety = returnSafeNumber(total_general_variety/total_wealth_pools);

    //Tracker tags
    current_scope.province_id = province_id;

    //Return statement
    return current_scope;
  },

  updateMigrationAttraction: function () {
    //Declare local instance variables
    var all_provinces = Object.keys(main.provinces);
    var all_users = Object.keys(main.users);
    var dynamic_tables = {};
    var migration_attraction = {};

    for (var i = 0; i < all_provinces.length; i++) {
      var local_province = main.provinces[all_provinces[i]];

      if (local_province.controller) {
        var local_migration_attraction = parseLimit(config.pop_migration.province_selection, {
          scope: ["province", all_provinces[i]]
        });

        if (local_migration_attraction.value > 0)
          modifyValue(migration_attraction, all_provinces[i], returnSafeNumber(local_migration_attraction.value));
      }
    }

    migration_attraction = sortObject(migration_attraction);
    var all_migration_attraction = Object.keys(migration_attraction);

    //Dynamic Tables - Internal Migration - [REVISIT] - This could be refactored in the future to make more sense
    {
      //Iterate over all_users to fetch internal migration attraction
      for (var i = 0; i < all_users.length; i++) {
        dynamic_tables[`${all_users[i]}-migration_attraction`] = {};
        dynamic_tables[`${all_users[i]}-external_migration_attraction`] = {};
      }

      //Iterate over all_migration_attraction; append each province dependent on control to dynamic_tables
      for (var i = 0; i < all_migration_attraction.length; i++) {
        var local_province = main.provinces[all_migration_attraction[i]];
        var local_value = migration_attraction[all_migration_attraction[i]];

        if (local_province.controller)
          dynamic_tables[`${local_province.controller}-migration_attraction`][local_province.id] = local_value;
      }

      //Standardise everything in dynamic_tables to 100%
      for (var i = 0; i < all_users.length; i++) {
        var local_key = `${all_users[i]}-migration_attraction`;
        var local_value = dynamic_tables[local_key];

        dynamic_tables[local_key] = sortObject(local_value);
        var new_dynamic_table = dynamic_tables[local_key];

        //Truncate dynamic tables at config.defines.economy.migration_provinces
        var all_internal_keys = Object.keys(new_dynamic_table);

        if (all_internal_keys.length > config.defines.economy.migration_provinces)
          for (var x = config.defines.economy.migration_provinces; x < all_internal_keys.length; x++)
            delete dynamic_tables[local_key][all_internal_keys[x]];

        //Add dynamic tables to lookup
        lookup[local_key] = dynamic_tables[local_key];
      }
    }

    //Dynamic Tables - External Migration
    {
      for (var i = 0; i < all_users.length; i++) {
        var key_name = `${all_users[i]}-external_migration_attraction`;
        var province_count = 0;

        //Iterate over all_migration_attraction
        for (var x = 0; x < all_migration_attraction.length; x++) {
          var local_province = main.provinces[all_migration_attraction[x]];
          var local_value = migration_attraction[all_migration_attraction[x]];

          //Upper bound guard clause
          if (province_count >= config.defines.economy.migration_provinces)
            break;
          if (local_province.controller != all_users[i]) {
            dynamic_tables[key_name][local_province.id] = local_value;
            province_count++;
          }
        }

        //Standardise percentage for local dynamic table, add to lookup
        lookup[key_name] = standardisePercentage(dynamic_tables[key_name]);
      }
    }

    //Truncate migration_attraction at config.defines.economy.migration_provinces
    if (all_migration_attraction.length > config.defines.economy.migration_provinces)
      for (var i = config.defines.economy.migration_provinces; i < all_migration_attraction.length; i++)
        delete migration_attraction[all_migration_attraction[i]];

    migration_attraction = standardisePercentage(migration_attraction);
    lookup.province_migration_attraction = migration_attraction;

    //Return statement
    return migration_attraction;
  }
};
