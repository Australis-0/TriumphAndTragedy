module.exports = {
  /*
    createPops() - Generates a certain number of pops for a given province with standard rolling. [WIP] - Add ability for pops to be generated by scope later
    options: {
      type: "all"/["workers", "soldiers"] - Chooses the types of pops to generate
      amount: 100000 - How many pops should be generated in the given province
    }
  */
  createPops: function (arg0_province, arg1_options) {
    //Convert from parameters
    var province_obj = getProvince(arg0_province);
    var options = arg1_options;

    //Initialise default options values
    options.type = (options.type) ? ["all"] : getList(options.type);

    //Declare local instance variables
    var all_pops = (options.type.includes("all")) ?
      Object.keys(config.pops) :
      options.type;
    var old_population = (province_obj.pops) ? JSON.parse(JSON.stringify(province_obj.pops)) : {};
    var relevant_pops = module.exports.getRelevantPops(user_id); //Returns pop key list
    var usr = (province_obj) ? main.users[province_obj.controller] : undefined;

    //Regular error trapping
    try {
      //Remove old user population so that it can be 'reset' to accomodate the new one
      usr.population -= province_obj.population;

      //Generate pops similar to settle_province.js
      var population_cache = options.amount;
      if (!province_obj.pops) province_obj.pops = {};

      //Generate all pops through chance
      var pop_chances = {}; //Standardise sum to 1

      for (var i = 0; i < relevant_pops.length; i++) {
        var local_pop = config.pops[relevant_pops[i]];

        if (local_pop.chance) {
          var random_percentage = randomNumber((local_pop.chance*100)/2, (local_pop.chance*100)*2, true);

          pop_chances[relevant_pops[i]] = random_percentage;
        }
      }

      pop_chances = standardiseObjectPercent(pop_chances);
      var all_pop_chances = Object.keys(pop_chances);

      //Partition pops in pop_chances
      for (var i = 0; i < all_pop_chances.length; i++) {
        var local_chance = pop_chances[all_pop_chances[i]];
        var population_change = parseInt(options.amount*local_chance);

        //Undefined pops save space in the DB
        modifyValue(province_obj.pops, all_pop_chances[i], population_change);
      }

      //Calculate new total population of province and add it to user tracker variables
      var all_local_pops = Object.keys(province_obj.pops);
      var total_population = 0;

      for (var i = 0; i < all_local_pops.length; i++)
        if (config.pops[all_local_pops[i]]) {
          var local_pop = province_obj.pops[all_local_pops[i]];
          usr.pops[all_local_pops[i]] += local_pop;
          total_population += local_pop;
        }

      //Add total_population back to usr.population and province tracker
      province_obj.pops.population = total_population;
      usr.population += total_population;
    } catch (e) {
      log.error(`createPops() ran into an error: ${e}.`);
    }
  },

  //getAllPopGoods() - Returns an array of all good keys demanded or produced by pop types w/ more than 0 people
  getAllPopGoods: function (arg0_user) { //[WIP] - Finish function body
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_goods = [];
    var relevant_pops = module.exports.getRelevantPops(user_id);
    var usr = main.users[actual_id];

    //Iterate over relevant_pops and recursively parse objects and subobjects for goods
    for (var i = 0; i < relevant_pops.length; i++) {
      var local_pop = config.pops[relevant_pops[i]];

      //max_modifier_limit
      if (local_pop.max_modifier_limit) {
        var max_modifier_limit_keys = Object.keys(local_pop.max_modifier_limit);

        for (var x = 0; x < max_modifier_limit_keys.length; x++)
          if (!all_pop_goods.includes(max_modifier_limit_keys[x]))
            if (lookup.all_goods[max_modifier_limit_keys[x]])
              all_pop_goods.push(max_modifier_limit_keys[x]);
      }

      //per_100k handler
      if (local_pop.per_100k) {
        var all_relevant_subgoods = getAllSubgoods(local_pop.per_100k);

        for (var x = 0; x < all_relevant_subgoods.length; x++)
          if (!all_pop_goods.includes(all_relevant_subgoods[x]))
            all_pop_goods.push(all_relevant_subgoods[x]);
      }
    }

    //Return statement
    return all_pop_goods;
  },

  getDemographics: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var all_provinces = getProvinces(user_id);
    var pop_obj = {};
    var usr = main.users[actual_id];

    //Iterate over all provinces and calculate population
    for (var i = 0; i < all_provinces.length; i++)
      for (var x = 0; x < all_pops.length; x++) {
        var local_key = `${all_provinces[i].type}_${all_pops[x]}`;

        pop_obj[local_key] = (pop_obj[local_key]) ?
          pop_obj[local_key] + all_provinces[i].pops[all_pops[x]] :
          all_provinces[i].pops[all_pops[x]];
      }

    //Get unique province types
    var all_pop_keys = Object.keys(pop_obj);
    var unique_province_types = [];

    for (var i = 0; i < all_pop_keys.length; i++) {
      var local_pop_array = all_pop_keys[i].split("_");

      if (!unique_province_types.includes(local_pop_array[0]))
        unique_province_types.push(local_pop_array[0]);
    }

    //Calculate total population for each province type
    for (var i = 0; i < unique_province_types.length; i++) {
      var local_key = `${unique_province_types[i]}_population`;

      pop_obj[local_key] = 0;

      for (var x = 0; x < all_pops.length; x++)
        pop_obj[local_key] += pop_obj[`${unique_province_types[i]}_${all_pops[x]}`];

      //Add to total population
      pop_obj.population = (pop_obj.population) ?
        pop_obj.population + pop_obj[local_key] :
        pop_obj[local_key];
    }

    //Return statement
    return pop_obj;
  },

  getFaminePenalty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var government_obj = config.governments[usr.government];
    var famine_penalty = (government_obj.effect.famine_penalty) ? government_obj.effect.famine_penalty : 0.1;
    var usr = main.users[actual_id];

    //Return statement
    return Math.ceil(usr.population*famine_penalty);
  },

  getMilitaryPops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var military_pop_types = [];

    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        military_pop_types.push(all_pops[i]);

    //Return statement
    return military_pop_types;
  },

  getPopModifier: function (arg0_user, arg1_type, arg2_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var total_modifier = 0;
    var total_pop_type = module.exports.getTotalPopManpower(user_id, pop_type);
    var usr = main.users[actual_id];

    //Regular error trapping just in case the specified modifier does not exist
    try {
      //Calculate total_modifier
      total_modifier = (total_pop_type/100000)*pop_obj.per_100k[raw_modifier];

      //Make sure to implement a proper cap
      if (pop_obj.max_modifier_limit)
        if (pop_obj.max_modifier_limit[raw_modifier])
          if (total_modifier > pop_obj.max_modifier_limit[raw_modifier])
            total_modifier = pop_obj.max_modifier_limit[raw_modifier];

      //Return statement
      return total_modifier;
    } catch (e) {
      log.error(`Could not calculate total pop modifier of type ${pop_type} for modifier ${raw_modifier}: ${e}`);
      console.error(e);
    }
  },

  getPopNeeds: function (arg0_type, arg1_amount, arg2_needs_category) {
    //Convert from parameters
    var pop_type = arg0_type;
    var amount = (arg1_amount) ? parseInt(arg1_amount) : 100000; //per_100k is the default needs scope
    var needs_category = arg2_needs_category;

    //Declare local instance variables
    var goods_obj = {};
    var needs_obj = (typeof needs_category != "object") ? needs_category.trim().toLowerCase() : undefined;
    var pop_obj = config.pops[pop_type];

    //Fetch needs_obj recursively
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs)
          needs_obj = (needs_category) ? JSON.parse(JSON.stringify(
            getSubobject(pop_obj.per_100k.needs, needs_category)
          )) : JSON.parse(JSON.stringify(pop_obj.per_100k.needs));

    //Multiply everything in needs_obj by a given amount
    needs_obj = multiplyObject(needs_obj, amount/100000, false, "ceil");

    return needs_obj;
  },

  /*
    getPopNeedsFulfilment() - Returns the total fulfilment of a set of pop needs.
    options: {
      needs_category: "food", - Which needs category to return fulfilment/variety for. Defaults to all
      return_object: true/false, - Whether to return the variety of goods and fulfilment used as a single object: { fulfilment: (Number), variety: (Number) }
      return_variety: true/false - Whether or not to return the variety of goods used in fulfilment instead of total fulfilment
    }
  */
  getPopNeedsFulfilment: function (arg0_goods, arg1_type, arg2_amount, arg3_options) {
    //Convert from parameters
    var goods_obj = arg0_goods; //These are the goods fulfilment is calculated against
    var pop_type = arg1_type;
    var amount = (arg2_amount) ? parseInt(arg2_amount) : 100000;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var all_goods = Object.keys(goods_obj);
    var multiplier = amount/100000;
    var pop_obj = config.pops[pop_type];
    var total_fulfilment = 0;
    var total_variety = 0;

    //Make sure pop has needs to begin with
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs) {
          var all_needs_groups = Object.keys(pop_obj.per_100k.needs).reverse();
          var is_needs_category = false;

          if (!options.needs_category) is_needs_category = true;
          if (pop_obj.per_100k.needs[options.needs_category]) {
            all_needs_groups = [options.needs_category];
            is_needs_category = true;
          }

          //Iterate through all_needs_keys in needs_obj and figure out its total fulfilment
          if (is_needs_category) {
            //all_needs_groups are things like "luxury_goods" in this boolean
            for (var i = 0; i < all_needs_groups.length; i++) {
              var divide_goods_obj = {}; //Total amount of categories that need a certain good key
              var local_needs_group = pop_obj.per_100k.needs[all_needs_groups[i]];

              var fulfilment_array = [];
              var variety_array = [];

              var all_local_needs_categories = Object.keys(local_needs_group);

              //Parse local fulfilment and variety for each
              for (var x = 0; x < all_local_needs_categories.length; x++) {
                //These are now objects like staple_goods.basics
                var local_needs_category = local_needs_group[all_local_needs_categories[x]];

                var all_local_goods = Object.keys(local_needs_category);
                var percent_fulfilled = 0;
                var percent_variety = 0;
                var total_goods = 0;

                //Calculate total_goods
                for (var y = 0; y < all_local_goods.length; y++) {
                  var local_value = local_needs_category[all_local_goods[y]];

                  total_goods += returnSafeNumber(local_value*multiplier);
                }

                //Iterate over all_local_goods to check for fulfilment; subtract resultant goods_obj[all_local_goods[y]] from goods_obj
                for (var y = 0; y < all_local_goods.length; y++) {
                  var local_allowance = returnSafeNumber(goods_obj[all_local_goods[y]]);
                  var local_value = local_needs_category[all_local_goods[y]]*multiplier;

                  //Calculate current_fulfillment, variety
                  var current_fulfillment = local_allowance/local_value;

                  percent_fulfilled += current_fulfillment*(local_value/total_goods);

                  if (local_allowance > 0)
                    percent_variety += 1/all_local_goods.length;

                  //Subtract from goods_obj[all_local_goods[y]]
                  if (local_allowance >= Math.ceil(local_value)) {
                    goods_obj[all_local_goods[y]] -= Math.ceil(local_value);
                  } else {
                    goods_obj[all_local_goods[y]] = 0;
                  }
                }

                //Push percent_fulfilled, percent_variety to fulfilment_array, variety_array
                fulfilment_array.push(percent_fulfilled);
                variety_array.push(percent_variety);
              }

              total_fulfilment += getAverage(fulfilment_array)*(1/all_needs_groups.length);
              total_variety += getAverage(variety_array)*(1/all_needs_groups.length);
            }
          } else {
            //This is a junior category such as .luxury_goods.food, treat it as such
            var needs_obj = module.exports.getPopNeeds(pop_type, amount, options.needs_category); //Already pre-multiplied
            var total_goods = 0;

            if (needs_obj) {
              //Calculate total_goods
              var all_needs_keys = Object.keys(needs_obj);

              for (var i = 0; i < all_needs_keys.length; i++)
                total_goods += returnSafeNumber(needs_obj[all_needs_keys[i]]);

              //Calculate total_fulfilment and total_variety
              for (var i = 0; i < all_needs_keys.length; i++) {
                var local_allowance = returnSafeNumber(goods_obj[all_needs_keys[i]]);
                var local_value = needs_obj[all_needs_keys[i]];

                //Add to total_fulfilment; total_variety
                total_fulfilment += (local_allowance/local_value)*(1/all_needs_keys.length);

                if (local_allowance > 0)
                  total_variety += 1/all_needs_keys.length;

                //Subtract from goods_obj[all_needs_keys[i]];
                if (local_allowance >= Math.ceil(local_value)) {
                  goods_obj[all_needs_keys[i]] -= Math.ceil(local_value);
                } else {
                  goods_obj[all_needs_keys[i]] = 0;
                }
              }
            }
          }
        }

    //Return statement
    if (!options.return_object) {
      return (!options.return_variety) ? total_fulfilment : total_variety;
    } else {
      return {
        fulfilment: total_fulfilment,
        variety: total_variety
      };
    }
  },

  getPopulation: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = module.exports.getDemographics(user_id);
    var usr = main.users[actual_id];

    //Return statement
    return pop_obj.population;
  },

  //getRelevantPops() - Returns an array of all pop keys with more than 0 population in a player country
  getRelevantPops: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_keys = Object.keys(config.pops);
    var relevant_pops = [];
    var usr = main.users[actual_id];

    //Iterate over all_pop_keys and check if usr.pops finds a match
    for (var i = 0; i < all_pop_keys.length; i++)
      if (usr.pops[all_pop_keys[i]]) {
        var local_pop = usr.pops[all_pop_keys[i]];
        var meets_conditions = true;

        //Global pop limit handling
        if (local_pop.disabled)
          meets_conditions = false;
        if (local_pop.industrial_pop)
          if (main.date.year < 1815)
            meets_conditions = false;

        if (meets_conditions)
          if (!relevant_pops.includes(all_pop_keys[i]))
            relevant_pops.push(all_pop_keys[i]);
      }

    //Return statement
    return relevant_pops;
  },

  getTotalActiveDuty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var total_active_duty = 0;
    var usr = main.users[actual_id];

    //Fetch total active duty
    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        total_active_duty += usr.pops[`used_${all_pops[i]}`];

    //Return statement
    return total_active_duty;
  },

  getTotalPopManpower: function (arg0_user, arg1_type, arg2_raw_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_raw_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var usr = main.users[actual_id];

    var availability_modifier = (pop_obj.military_pop) ?
      usr.modifiers.maximum_manpower*usr.modifiers.national_manpower
      : 1;

    //Return statement
    return (!raw_modifier) ? Math.ceil(usr.pops[pop_type]*availability_modifier) : availability_modifier;
  },

  parsePops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);

    //Process pop objects
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      //Set icon values
      if (local_pop.icon) local_pop.icon = config.icons[local_pop.icon];
    }
  },

  /*
    removePop() - Removes pops from a province
    options: {
      province_id: "6709", - The province ID which to target pops from

      pop_type: "soldiers", - Which type of pop to kill off. Doesn't accept lists
      amount: 5000 - How much of the pop to kill off
    }
  */
  removePop: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var killed = 0;
    var province_obj = main.provinces[options.province_id];
    var usr = main.users[actual_id];

    //Subtract population
    if (province_obj)
      if (province_obj.pops[options.pop_type]) {
        if (province_obj.pops[options.pop_type] >= options.amount) {
          killed = JSON.parse(JSON.stringify(options.amount));
          province_obj.pops[options.pop_type] -= options.amount;
        } else {
          killed = JSON.parse(JSON.stringify(province_obj.pops[options.pop_type]));
          province_obj.pops[options.pop_type] = 0;
        }
      }

    //Return statement
    return killed;
  },

  /*
    removePops() - Kills a certain number of pops from a user based on the available options.
    options: {
      migration: true/false, - Whether the pops migrated or not instead of being killed. False by default
      provinces: ["6709", "6710"], - A list of provinces to target for removing pops. All of a user's provinces by default
      type: "soldiers", - Which type of pop to kill off
      amount: 10000 - How much of the pop to kill off
    }
  */
  removePops: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = arg1_options;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var decimation_obj = {};
    var pop_obj = config.pops[options.type];
    var pop_types = getList(options.type);
    var remaining_population = returnSafeNumber(options.amount);
    var shuffled_provinces = shuffleArray(getProvinces(user_id));
    var usr = main.users[actual_id];

    var target_provinces = (options.provinces) ? getList(options.provinces) : shuffled_provinces;

    //Parse 'all' argument as well
    pop_types = (pop_types.includes("all")) ? Object.keys(config.pops) : pop_types;

    //Assign decimation_array to decimation_obj
    var decimation_array = splitNumber(1, pop_types.length);

    for (var i = 0; i < pop_types.length; i++)
      decimation_obj[pop_types[i]] = decimation_array[i];

    //Begin subtracting pops
    for (var i = 0; i < pop_types.length; i++) {
      var amount_to_remove = decimation_obj[pop_types[i]];
      var total_pops = 0;

      //Sum up total_pops from target_provinces
      for (var x = 0; x < target_provinces.length; x++) {
        var local_province = main.provinces[target_provinces[x]];

        if (local_province.pops)
          if (local_province.pops[pop_types[i]])
            total_pops += local_province.pops[pop_types[i]];
      }

      var total_pop_percentage = returnSafeNumber(amount_to_remove/total_pops);

      //Subtract local_province.pops[pop_types[i]]*total_pop_percentage from each city
      for (var x = 0; x < target_provinces.length; x++) {
        var local_province = main.provinces[target_provinces[x]];
        var local_removed_pops = module.exports.removePop(user_id, {
          province_id: target_provinces[x],

          pop_type: pop_types[i],
          amount: local_province.pops[pop_types[i]]*total_pop_percentage
        });

        decimation_obj[pop_types[i]] -= local_removed_pops;
      }
    }

    //Add to civilian/military casualties tracker
    if (!options.migration)
      if (!getList(options.type).includes("all")) {
        if (pop_obj.military_pop) {
          usr.recent_military_casualties[usr.recent_military_casualties.length - 1] += options.amount;
        } else {
          usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += options.amount;
        }
      } else {
        usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += options.amount;
      }

    //Return statement
    return decimation_obj;
  }
};
