module.exports = {
  /*
    createPops() - Generates a certain number of pops for a given province with standard rolling. [WIP] - Add ability for pops to be generated by scope later
    options: {
      culture: "09418904328", - Optional. The ID of the culture to generate pops for. Undefined by default
      type: "all"/["workers", "soldiers"] - Chooses the types of pops to generate
      amount: 100000 - How many pops should be generated in the given province
    }
  */
  createPops: function (arg0_province, arg1_options) {
    //Convert from parameters
    var province_obj = getProvince(arg0_province);
    var options = arg1_options;

    //Initialise default options values
    options.type = (options.type) ? ["all"] : getList(options.type);

    //Declare local instance variables
    var all_pops = (options.type.includes("all")) ?
      Object.keys(config.pops) :
      options.type;
    var old_population = (province_obj.pops) ? JSON.parse(JSON.stringify(province_obj.pops)) : {};
    var relevant_pops = module.exports.getRelevantPops(user_id); //Returns pop key list
    var usr = (province_obj) ? main.users[province_obj.controller] : undefined;

    //Regular error trapping
    try {
      //Remove old user population so that it can be 'reset' to accomodate the new one
      usr.population -= province_obj.population;

      //Generate pops similar to settle_province.js
      var population_cache = options.amount;
      if (!province_obj.pops) province_obj.pops = {};

      //Generate all pops through chance
      var pop_chances = {}; //Standardise sum to 1

      for (var i = 0; i < relevant_pops.length; i++) {
        var local_pop = config.pops[relevant_pops[i]];

        if (local_pop.chance) {
          var random_percentage = randomNumber((local_pop.chance*100)/2, (local_pop.chance*100)*2, true);

          pop_chances[relevant_pops[i]] = random_percentage;
        }
      }

      pop_chances = standardisePercentage(pop_chances);
      var all_pop_chances = Object.keys(pop_chances);
      var culture_percentages = getProvinceCulture(province_obj.id);

      var all_cultures = Object.keys(culture_percentages);

      //Partition pops in pop_chances
      for (var i = 0; i < all_pop_chances.length; i++) {
        var local_chance = pop_chances[all_pop_chances[i]];
        var population_change = parseInt(options.amount*local_chance);

        //Undefined pops save space in the DB
        modifyValue(province_obj.pops, all_pop_chances[i], population_change);

        //Distribute cultures proportionally
        if (!options.culture) {
          for (var x = 0; x < all_cultures.length; x++)
            modifyValue(province_obj.pops, options.culture, population_change*Math.floor(culture_percentages[all_cultures[x]]));
        } else {
          modifyValue(province_obj.pops, options.culture, population_change);
        }
      }

      //Calculate new total population of province and add it to user tracker variables
      {
        var all_local_pops = Object.keys(province_obj.pops);
        var total_population = 0;

        for (var i = 0; i < all_local_pops.length; i++)
          if (config.pops[all_local_pops[i]]) {
            var local_value = province_obj.pops[all_local_pops[i]];

            usr.pops[all_local_pops[i]] += local_value;
            total_population += local_value;
          }
      }

      //Add total_population back to usr.population and province tracker
      province_obj.pops.population = total_population;
      usr.population += total_population;
    } catch (e) {
      log.error(`createPops() ran into an error: ${e}.`);
    }
  },

  /*
    getActualPopFulfilment() - Gets actual pop fulfilment for the stated scope as a weighted average by wealth pool.
    options: {
      province_id: "4709", - The province ID which to target
      pop_type: "soldiers", - The pop type for which to fetch fulfilment/variety for

      good_scope: "staple_goods"/"chocolate" - Optional. Defaults to all. Individual goods are calculated with received_goods per category per wealth pool.
    }
  */
  getActualPopFulfilment: function (arg0_options) { //[WIP] - Add subsidy and subsistence calculations later
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var fulfilment = 0;
    var province_id = options.province_id;
    var province_obj = main.provinces[province_id];
    var total_fulfilment = 0;
    var total_variety = 0;
    var variety = 0;

    if (province_obj.pops) {
      var all_pop_keys = Object.keys(province_obj.pops);
      var is_good = (lookup.all_goods[options.good_scope]);
      var local_population = returnSafeNumber(province_obj.pops[options.pop_type]);

      for (var i = 0; i < all_pop_keys.length; i++)
        if (all_pop_keys[i].startsWith("wealth-")) {
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
          var split_key = all_pop_keys[i].split("-");

          var pop_type = split_key[2];

          if (pop_type == options.pop_type) {
            var has_needs = false;
            var pop_obj = config.pops[pop_type];
            var total_goods = 0;
            var total_subgoods_fulfilled = 0;

            if (pop_obj.per_100k)
              if (pop_obj.per_100k.needs) has_needs = true;

            if (has_needs) {
              if (is_good) {
                var local_subgoods = lookup.all_subgoods[options.good_scope];
                var per_100k_need = 0;

                for (var x = 0; x < pop_obj.buy_order.length; x++) {
                  var local_needs_category = pop_obj.per_100k.needs[pop_obj.buy_order[x]];
                  var local_received_goods = local_wealth_pool.received_goods[pop_obj.buy_order[x]];

                  for (var y = 0; y < local_subgoods.length; y++)
                    if (local_received_goods[local_subgoods[y]]) {
                      var local_value = local_received_goods[local_subgoods[y]];

                      total_goods += returnSafeNumber(local_value);
                      if (local_value > 0) total_subgoods_fulfilled++;

                      per_100k_need += returnSafeNumber(local_needs_category[local_subgoods[y]]);
                    }
                }

                var actual_need = per_100k_need*(local_wealth_pool.size/100000);

                //Set total_fulfilment; total_variety
                total_fulfilment += Math.min(local_wealth_pool.size*(total_goods/actual_need), local_wealth_pool.size);
                total_variety += Math.min(local_wealth_pool.size*(total_subgoods_fulfilled/local_subgoods.length), local_wealth_pool.size);
              } else if (pop_obj.buy_order.includes(options.good_scope)) {
                total_fulfilment += local_wealth_pool.size*returnSafeNumber(local_wealth_pool[`${options.good_scope}-fulfilment`]);
                total_variety += local_wealth_pool.size*returnSafeNumber(local_wealth_pool[`${options.good_scope}-variety`]);
              } else {
                //All handler
                total_fulfilment += local_wealth_pool.size*returnSafeNumber(local_wealth_pool.fulfilment);
                total_variety += local_wealth_pool.size*returnSafeNumber(local_wealth_pool.variety);
              }
            } else {
              total_fulfilment += local_wealth_pool.size*config.defines.economy.default_fulfilment;
              total_variety += local_wealth_pool.size*config.defines.economy.default_variety;
            }
          }
        }

      //Set fulfilment; variety
      fulfilment = total_fulfilment/local_population;
      variety = total_variety/local_population;

      //Return statement
      return {
        fulfilment: fulfilment,
        variety: variety
      };
    }
  },

  //getAllPopGoods() - Returns an array of all good keys demanded or produced by pop types w/ more than 0 people
  getAllPopGoods: function (arg0_user) { //[WIP] - Finish function body
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_goods = [];
    var relevant_pops = module.exports.getRelevantPops(user_id);
    var usr = main.users[actual_id];

    //Iterate over relevant_pops and recursively parse objects and subobjects for goods
    for (var i = 0; i < relevant_pops.length; i++) {
      var local_pop = config.pops[relevant_pops[i]];

      //max_modifier_limit
      if (local_pop.max_modifier_limit) {
        var max_modifier_limit_keys = Object.keys(local_pop.max_modifier_limit);

        for (var x = 0; x < max_modifier_limit_keys.length; x++)
          if (!all_pop_goods.includes(max_modifier_limit_keys[x]))
            if (lookup.all_goods[max_modifier_limit_keys[x]])
              all_pop_goods.push(max_modifier_limit_keys[x]);
      }

      //per_100k handler
      if (local_pop.per_100k) {
        var all_relevant_subgoods = getAllSubgoods(local_pop.per_100k);

        for (var x = 0; x < all_relevant_subgoods.length; x++)
          if (!all_pop_goods.includes(all_relevant_subgoods[x]))
            all_pop_goods.push(all_relevant_subgoods[x]);
      }
    }

    //Return statement
    return all_pop_goods;
  },

  //getAllPopNeeds() - Returns an object of all flattened pop needs
  getAllPopNeeds: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var all_pop_needs_obj = {};

    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs)
          all_pop_needs_obj[all_pops[i]] = flattenObject(local_pop.per_100k.needs);
    }

    return all_pop_needs_obj;
  },

  //getAllPopNeedCategories() - Returns a list of pop need categories such as luxury_goods, staple_goods, etc.
  getAllPopNeedCategories: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var pop_categories = [];

    //Iterate over all_pops
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs) {
          var all_local_needs_categories = Object.keys(local_pop.per_100k.needs);

          for (var x = 0; x < all_local_needs_categories.length; x++)
            if (!pop_categories.includes(all_local_needs_categories[x]))
              pop_categories.push(all_local_needs_categories[x]);
        }
    }

    //Return statement
    return pop_categories;
  },

  getCityPopGrowth: function (arg0_name, arg1_options) {
    //Convert from parameters
    var city_name = arg0_name;
    var options = (arg1_options) ? arg1_options : { pop_type: "all" };

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var city_obj = (typeof city_name != "object") ? getCity(city_name) : city_name;
    var total_growth = 0;
    var usr = main.users[city_obj.controller];

    //Calcualte total growth
    if (options.pop_type == "all") {
      for (var i = 0; i < all_pops.length; i++)
        total_growth += Math.ceil(
          city_obj.pops[all_pops[i]]*
          module.exports.getCityPopGrowthRate(city_obj, { pop_type: all_pops[i] })
        );
    } else {
      total_growth = Math.ceil(
        city_obj.pops[options.pop_type]*
        module.exports.getCityPopGrowthRate(city_obj, { pop_type: options.pop_type })
      );
    }

    //Return statement
    return total_growth;
  },

  /*
    getCityPopGrowthRate() - Returns the decimal percentage growth of a given city.
    options: {
      pop_type: "workers" - The pop type to calculate growth for. Defaults to 'all'
    }
  */
  getCityPopGrowthRate: function (arg0_name, arg1_options) {
    //Convert from parameters
    var city_name = arg0_name;
    var options = (arg1_options) ? arg1_options : { pop_type: "all" };

    //Declare local instance variables
    var city_obj = (typeof city_name != "object") ? getCity(city_name) : city_name;
    var scalar = 1;
    var usr = main.users[city_obj.controller];

    var local_growth_modifier = (options.pop_type != "all") ?
      usr.pops[`${options.pop_type}_growth_modifier`] : 1;

    //Local pop growth logic
    {
      //Calculate scalar
      if (city_obj.pops.population > config.defines.economy.urban_pop_growth_penalty_threshold) //-3% per million
        scalar -= Math.ceil(
          (city_obj.pops.population - config.defines.economy.urban_pop_growth_penalty_threshold)/1000000
        )*config.defines.economy.urban_pop_growth_penalty_per_million;

      //Calculate urban pop growth rate for chosen pop
      var local_pop_growth_rate = (
        local_growth_modifier*
        scalar*
        usr.modifiers.pop_growth_modifier
      );

      //Set local pop growth cap from economy defines
      var urban_growth_cap;
      for (var y = 0; y < config.defines.economy.urban_pop_growth_cap.length; y++) {
        var local_element = config.defines.economy.urban_pop_growth_cap[y];

        if (city_obj.pops.population >= local_element[0])
          urban_growth_cap = local_element[1];
      }

      if (urban_growth_cap)
        local_pop_growth_rate = Math.min(local_pop_growth_rate, urban_growth_cap);

      //Cap to maximum
      if (config.defines.economy.urban_pop_maximum_growth_rate)
        local_pop_growth_rate = Math.min(local_pop_growth_rate, config.defines.economy.urban_pop_maximum_growth_rate);

      //Occupation penalty
      if (city_obj.controller != city_obj.owner)
        local_pop_growth_rate = local_pop_growth_rate*config.defines.economy.occupation_pop_growth_penalty;

      //Make sure population can't drop by more than 100%
      if (local_pop_growth_rate < -1)
        local_pop_growth_rate = local_pop_growth_rate % 1;
    }

    //Return statement
    return local_pop_growth_rate;
  },

  getDemographics: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var all_provinces = getProvinces(user_id);
    var pop_obj = {};
    var usr = main.users[actual_id];

    //Iterate over all provinces and calculate population
    for (var i = 0; i < all_provinces.length; i++)
      for (var x = 0; x < all_pops.length; x++) {
        var local_key = `${all_provinces[i].type}_${all_pops[x]}`;

        pop_obj[local_key] = (pop_obj[local_key]) ?
          pop_obj[local_key] + all_provinces[i].pops[all_pops[x]] :
          all_provinces[i].pops[all_pops[x]];
      }

    //Get unique province types
    var all_pop_keys = Object.keys(pop_obj);
    var unique_province_types = [];

    for (var i = 0; i < all_pop_keys.length; i++) {
      var local_pop_array = all_pop_keys[i].split("_");

      if (!unique_province_types.includes(local_pop_array[0]))
        unique_province_types.push(local_pop_array[0]);
    }

    //Calculate total population for each province type
    for (var i = 0; i < unique_province_types.length; i++) {
      var local_key = `${unique_province_types[i]}_population`;

      pop_obj[local_key] = 0;

      for (var x = 0; x < all_pops.length; x++)
        pop_obj[local_key] += pop_obj[`${unique_province_types[i]}_${all_pops[x]}`];

      //Add to total population
      pop_obj.population = (pop_obj.population) ?
        pop_obj.population + pop_obj[local_key] :
        pop_obj[local_key];
    }

    //Return statement
    return pop_obj;
  },

  //getEmploymentPercentages() - Returns employment percentages for a pop type by building in a province
  getEmploymentPercentages: function (arg0_province_id, arg1_type) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;

    //Declare local instance variables
    var employment_obj = {};
    var employed_pops = 0;
    var province_obj = main.provinces[province_id];

    if (province_obj.buildings) {
      var all_pop_keys = Object.keys(province_obj.pops);

      for (var i = 0; i < all_pop_keys.length; i++)
        if (all_pop_keys[i].startsWith("wealth-")) {
          var split_wealth_key = all_pop_keys[i].split("-");

          var building_id = split_wealth_key[1];
          var local_pop_type = split_wealth_key[2];
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];

          if (local_pop_type == pop_type) {
            employment_obj[building_id] = local_wealth_pool.size;
            employed_pops += local_wealth_pool.size;
          }
        }

      //Adjust to percentage of employed_pops
      var all_employment_keys = Object.keys(employment_obj);

      for (var i = 0; i < all_employment_keys.length; i++) {
        var local_value = employment_obj[all_employment_keys[i]];

        employment_obj[all_employment_keys[i]] = local_value/employed_pops;
      }
    }

    //Return statement
    return sortObject(employment_obj);
  },

  getFaminePenalty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var government_obj = config.governments[usr.government];
    var famine_penalty = (government_obj.effect.famine_penalty) ? government_obj.effect.famine_penalty : 0.1;
    var usr = main.users[actual_id];

    //Return statement
    return Math.ceil(usr.population*famine_penalty);
  },

  /*
    getJobOpenings() - Fetches the total number of job openings for a pop type in a province based on specified criteria.
    options: {
      income: 15, - What the wage of this job should be >= to
      living_wage: true/false - Whether this is enough for the pop to afford config.defines.economy.staple_goods_categories
    }
  */
  getJobOpenings: function (arg0_province_id, arg1_pop_type, arg2_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_pop_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var province_obj = main.provinces[province_id];
    var total_openings = 0;

    if (province_obj)
      if (province_obj.buildings)
        for (var i = 0; i < province_obj.buildings.length; i++) {
          var local_building = province_obj.buildings[i];
          var local_positions = local_building[`${pop_type}_positions`];
          var local_wage = local_building[`${pop_type}_wage`];
          var meets_conditions = true;

          if (local_wage < returnSafeNumber(options.income))
            meets_conditions = false;
          if (options.living_wage) {
            var living_wage = getStapleGoodsPrice(pop_type);

            if (local_wage < living_wage)
              meets_conditions = false;
          }

          if (meets_conditions)
            total_openings += returnSafeNumber(province_obj.buildings[i][`${pop_type}_positions`]);
        }

    //Return statement
    return total_openings;
  },

  getMilitaryPops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var military_pop_types = [];

    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        military_pop_types.push(all_pops[i]);

    //Return statement
    return military_pop_types;
  },

  //Updates config.pops with a new needs_importance object for buying order reference
  getNeedsImportance: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var defines_obj = config.defines.economy.good_categories;

    //Iterate over all pops and subcategories
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.per_100k)
        if (local_pop.per_100k.needs) {
          var local_needs = local_pop.per_100k.needs;
          local_pop.needs_importance = {};

          var all_local_needs_categories = Object.keys(local_needs);
          var needs_importance = local_pop.needs_importance;

          for (var x = 0; x < all_local_needs_categories.length; x++) {
            var local_needs_category = local_needs[all_local_needs_categories[x]];
            var local_needs_obj = {};

            var all_local_needs_subcategories = Object.keys(local_needs_category);

            for (var y = 0; y < all_local_needs_subcategories.length; y++) {
              var local_needs_group = local_needs_category[all_local_needs_subcategories[y]];

              var all_local_needs = Object.keys(local_needs_group);
              var auto_priority = false;
              var total_importance = 0;
              var total_marginal_utility = 0;
              var type_count = {}; //Counts the number of goods of each type for automatic_priority setting

              for (var z = 0; z < all_local_needs.length; z++) {
                var local_good = lookup.all_goods[all_local_needs[z]];

                if (local_good)
                  if (local_good.type) {
                    var local_define = defines_obj[local_good.type];

                    if (local_define) {
                      //Add to total_importance and total_marginal_utility
                      total_importance += (local_define.importance != "unlimited") ?
                        returnSafeNumber(local_define.importance) : 99999;
                      total_marginal_utility += returnSafeNumber(local_define.marginal_utility);

                      modifyValue(type_count, local_good.type, 1);
                    }
                  }
              }

              //Average total_importance and total_marginal_utility, check for automatic_priority percentage
              var all_types = Object.keys(type_count);
              var average_importance = total_importance/all_local_needs.length;
              var average_marginal_utility = total_marginal_utility/all_local_needs.length;

              for (var z = 0; z < all_types.length; z++) {
                var local_define = defines_obj[all_types[z]];
                var local_value = type_count[all_types[z]];

                if (local_define)
                  if (local_value >= returnSafeNumber(local_define.automatic_priority))
                    auto_priority = true;
              }

              //Format local_needs_obj[all_local_needs_subcategories[y]]
              var local_needs_group = {
                importance: average_importance,
                marginal_utility: average_marginal_utility
              };

              if (auto_priority) local_needs_group.automatic_priority = true;
              local_needs_obj[all_local_needs_subcategories[y]] = local_needs_group;
            }

            //Set needs_importance object for pop
            local_pop.needs_importance[all_local_needs_categories[x]] = local_needs_obj;
          }

          //Iterate over all_local_needs_categories again to create a .buy_order array for categories
          var category_importances = [];

          for (var x = 0; x < all_local_needs_categories.length; x++) {
            var actual_importances = [];
            var local_needs_category = local_needs[all_local_needs_categories[x]];

            var actual_importance_array = [];
            var importance_array = []; //This will be sorted in descending order
            var total_importance = 0;

            var all_local_needs_subcategories = Object.keys(local_needs_category);

            for (var y = 0; y < all_local_needs_subcategories.length; y++) {
              var local_importance = local_pop.needs_importance[all_local_needs_categories[x]][all_local_needs_subcategories[y]];

              var local_actual_importance = (local_importance.automatic_priority) ?
                returnSafeNumber(local_importance.importance) : 99999;

              importance_array.push({ name: all_local_needs_subcategories[y], importance: local_actual_importance });
              total_importance += local_actual_importance;
            }

            //Sort importance_array
            importance_array.sort((a, b) => { b.importance - a.importance });

            for (var y = 0; y < importance_array.length; y++)
              actual_importance_array.push(importance_array[y]);
            local_pop[`${all_local_needs_categories[x]}-buy_order`] = actual_importance_array;

            category_importances.push({
              name: all_local_needs_categories[x],
              importance: total_importance/all_local_needs_subcategories.length
            });
          }

          //Sort category_importances
          category_importances.sort((a, b) => { b.importance - a.importance });

          for (var x = 0; x < category_importances.length; x++)
            actual_importances.push(category_importances[x].name);

          if (!local_pop.buy_order)
            local_pop.buy_order = actual_importances;
        }
    }
  },

  getPopModifier: function (arg0_user, arg1_type, arg2_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var total_modifier = 0;
    var total_pop_type = module.exports.getTotalPopManpower(user_id, pop_type);
    var usr = main.users[actual_id];

    //Regular error trapping just in case the specified modifier does not exist
    try {
      //Calculate total_modifier
      total_modifier = (total_pop_type/100000)*pop_obj.per_100k[raw_modifier];

      //Make sure to implement a proper cap
      if (pop_obj.max_modifier_limit)
        if (pop_obj.max_modifier_limit[raw_modifier])
          if (total_modifier > pop_obj.max_modifier_limit[raw_modifier])
            total_modifier = pop_obj.max_modifier_limit[raw_modifier];

      //Return statement
      return total_modifier;
    } catch (e) {
      log.error(`Could not calculate total pop modifier of type ${pop_type} for modifier ${raw_modifier}: ${e}`);
      console.error(e);
    }
  },

  /*
    getPopNeeds() - Fetches generic pop needs for a given pop type
    options: {
      province_id: "4407" - Uses wealth pools to account for rounding issues
    }
  */
  getPopNeeds: function (arg0_type, arg1_amount, arg2_needs_category, arg3_options) {
    //Convert from parameters
    var pop_type = arg0_type;
    var amount = (arg1_amount != undefined) ? parseInt(arg1_amount) : 100000; //per_100k is the default needs scope
    var needs_category = arg2_needs_category;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var goods_obj = {};
    var needs_obj = (typeof needs_category != "object" && needs_category) ? needs_category.trim().toLowerCase() : undefined;
    var pop_obj = config.pops[pop_type];
    var wealth_pools_amount = 0;

    //Fetch needs_obj recursively
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs)
          try {
            needs_obj = (needs_category) ? JSON.parse(JSON.stringify(
              getSubobject(pop_obj.per_100k.needs, needs_category)
            )) : JSON.parse(JSON.stringify(pop_obj.per_100k.needs));

            //Fetch wealth_pools_amount
            if (options.province_id) {
              var province_obj = main.provinces[options.province_id];

              if (province_obj)
                if (province_obj.pops) {
                  var all_pop_keys = Object.keys(province_obj.pops);

                  for (var i = 0; i < all_pop_keys.length; i++)
                    if (all_pop_keys[i].startsWith("wealth-")) {
                      var local_pop_type = all_pop_keys[i].split("-")[2];

                      if (local_pop_type == pop_type)
                        wealth_pools_amount++;
                    }
                }
            }
          } catch {
            needs_obj = {};
          }

    //Multiply everything in needs_obj by a given amount
    needs_obj = removeZeroes(multiplyObject(needs_obj, amount/100000, false, "ceil"));

    //Account for rounding errors
    needs_obj = addObject(needs_obj, wealth_pools_amount);

    return needs_obj;
  },

  /*
    getPopNeedsFulfilment() - Returns the total fulfilment of a set of pop needs.
    options: {
      needs_category: "food", - Which needs category to return fulfilment/variety for. Defaults to all
      return_object: true/false, - Whether to return the variety of goods and fulfilment used as a single object: { fulfilment: (Number), variety: (Number) }
      restrict_goods: ["food", "bread"], - Goods to restrict calculations to
      return_variety: true/false - Whether or not to return the variety of goods used in fulfilment instead of total fulfilment
    }
  */
  getPopNeedsFulfilment: function (arg0_goods, arg1_type, arg2_amount, arg3_options) {
    //Convert from parameters
    var goods_obj = arg0_goods; //These are the goods fulfilment is calculated against
    var pop_type = arg1_type;
    var amount = (arg2_amount) ? parseInt(arg2_amount) : 100000;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var all_goods = Object.keys(goods_obj);
    var allowed_goods = (!options.restrict_goods) ? lookup.all_good_names : getList(options.restrict_goods);
    var multiplier = amount/100000;
    var pop_obj = config.pops[pop_type];
    var total_fulfilment = 0;
    var total_variety = 0;

    //Make sure pop has needs to begin with
    if (pop_obj)
      if (pop_obj.per_100k)
        if (pop_obj.per_100k.needs) {
          var all_needs_groups = Object.keys(pop_obj.per_100k.needs).reverse();
          var is_needs_category = false;

          if (!options.needs_category) is_needs_category = true;
          if (pop_obj.per_100k.needs[options.needs_category]) {
            all_needs_groups = [options.needs_category];
            is_needs_category = true;
          }

          //Iterate through all_needs_keys in needs_obj and figure out its total fulfilment
          if (is_needs_category) {
            //all_needs_groups are things like "luxury_goods" in this boolean
            for (var i = 0; i < all_needs_groups.length; i++) {
              var divide_goods_obj = {}; //Total amount of categories that need a certain good key
              var local_needs_group = pop_obj.per_100k.needs[all_needs_groups[i]];

              var fulfilment_array = [];
              var variety_array = [];

              var all_local_needs_categories = Object.keys(local_needs_group);
              var total_need_groups = all_local_needs_categories.length;

              //Remove total_need_groups
              for (var x = 0; x < all_local_needs_categories.length; x++) {
                var has_subgood = false;

                var local_needs_category = local_needs_group[all_local_needs_categories[x]];

                if (!options.restrict_goods) has_subgood = true;
                if (options.restrict_goods)
                  for (var y = 0; y < options.restrict_goods.length; y++)
                    if (local_needs_category[options.restrict_goods[y]])
                      has_subgood = true;

                if (!has_subgood)
                  total_need_groups--;
              }

              //Parse local fulfilment and variety for each
              for (var x = 0; x < all_local_needs_categories.length; x++) {
                var has_subgood = false;

                //These are now objects like staple_goods.basics
                var local_needs_category = local_needs_group[all_local_needs_categories[x]];

                var all_local_goods = Object.keys(local_needs_category);
                var percent_fulfilled = 0;
                var percent_variety = 0;
                var total_goods = 0;

                if (!options.restrict_goods) has_subgood = true;
                if (options.restrict_goods)
                  for (var y = 0; y < options.restrict_goods.length; y++)
                    if (local_needs_category[options.restrict_goods[y]])
                      has_subgood = true;

                //Calculate total_goods
                for (var y = 0; y < all_local_goods.length; y++) {
                  var local_value = local_needs_category[all_local_goods[y]];

                  if (allowed_goods.includes(all_local_goods[y]))
                    total_goods += returnSafeNumber(local_value*multiplier);
                }

                //Iterate over all_local_goods to check for fulfilment; subtract resultant goods_obj[all_local_goods[y]] from goods_obj
                for (var y = 0; y < all_local_goods.length; y++)
                  if (allowed_goods.includes(all_local_goods[y])) {
                    var local_good = lookup.all_goods[all_local_goods[y]];

                    var local_allowance = returnSafeNumber(goods_obj[all_local_goods[y]]);
                    var local_goods_amount = (!options.restrict_goods) ? all_local_goods.length : options.restrict_goods.length;
                    var local_value = local_needs_category[all_local_goods[y]]*multiplier;

                    //Calculate current_fulfillment, variety
                    var current_fulfillment = local_allowance/local_value;

                    percent_fulfilled += current_fulfillment*(local_value/total_goods);

                    if (local_allowance > 0)
                      percent_variety += 1/local_goods_amount;

                    //Subtract from goods_obj[all_local_goods[y]]
                    goods_obj[all_local_goods[y]] = Math.max(goods_obj[all_local_goods[y]] - local_value, 0);

                    //Special variety parsing logic for local_good.type 'category'
                    if (local_good.type == "category") {
                      var all_subgood_keys = getSubobjectKeys(local_good, { exclude_keys: reserved.goods, only_objects: true });

                      percent_variety = 0;

                      for (var z = 0; z < all_subgood_keys.length; z++) {
                        var local_subgood = lookup.all_goods[all_subgood_keys[z]];

                        if (local_subgood) {
                          var local_subgood_allowance = goods_obj[all_subgood_keys[z]];

                          if (local_subgood_allowance > 0)
                            percent_variety += returnSafeNumber(1/all_subgood_keys.length);
                        }
                      }
                    }
                  }

                //Push percent_fulfilled, percent_variety to fulfilment_array, variety_array
                if (has_subgood) {
                  fulfilment_array.push(Math.min(percent_fulfilled, 1));
                  variety_array.push(Math.min(percent_variety, 1));
                }
              }
              total_fulfilment += returnSafeNumber(getAverage(fulfilment_array)*(1/total_need_groups));
              total_variety += returnSafeNumber(getAverage(variety_array)*(1/total_need_groups));
            }
          } else {
            //This is a junior category such as .luxury_goods.food, treat it as such
            var needs_obj = module.exports.getPopNeeds(pop_type, amount, options.needs_category); //Already pre-multiplied
            var total_goods = 0;

            if (needs_obj) {
              //Calculate total_goods
              var all_needs_keys = Object.keys(needs_obj);
              var needs_amount = (!options.restrict_goods) ? all_needs_keys.length : options.restrict_goods.length;

              for (var i = 0; i < all_needs_keys.length; i++)
                if (allowed_goods.includes(all_needs_keys[i]))
                  total_goods += returnSafeNumber(needs_obj[all_needs_keys[i]]);

              //Calculate total_fulfilment and total_variety
              for (var i = 0; i < all_needs_keys.length; i++)
                if (allowed_goods.includes(all_needs_keys[i])) {
                  var local_allowance = returnSafeNumber(goods_obj[all_needs_keys[i]]);
                  var local_value = needs_obj[all_needs_keys[i]];

                  //Add to total_fulfilment; total_variety
                  total_fulfilment += Math.min((local_allowance/local_value)*(1/needs_amount));

                  if (local_allowance > 0)
                    total_variety += 1/needs_amount;

                  //Subtract from goods_obj[all_needs_keys[i]];
                  if (local_allowance >= Math.ceil(local_value)) {
                    goods_obj[all_needs_keys[i]] -= Math.ceil(local_value);
                  } else {
                    goods_obj[all_needs_keys[i]] = 0;
                  }
                }
            }
          }
        }

    //Return statement
    if (!options.return_object) {
      return (!options.return_variety) ? total_fulfilment : total_variety;
    } else {
      return {
        fulfilment: total_fulfilment,
        variety: total_variety
      };
    }
  },

  getPopulation: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = module.exports.getDemographics(user_id);
    var usr = main.users[actual_id];

    //Return statement
    return pop_obj.population;
  },

  getProvinceBirths: function (arg0_user, arg1_province_id) {
    //Convert from parameters
    var user_id = arg0_user;
    var province_id = arg1_province_id;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var births = {}; //Split by pop type
    var province_obj = main.provinces[province_id];
    var usr = main.users[actual_id];

    //Check if province exists and for urban/rural growth dichotomy
    if (province_obj)
      if (province_obj.controller == province_obj.owner)
        if (province_obj.type == "urban") {
          //Calculate urban pop growth for all pops
          for (var i = 0; i < all_pops.length; i++) {
            var local_pop_growth = module.exports.getCityPopGrowth(province_obj, { pop_type: all_pops[i] });

            if (province_obj.housing > province_obj.pops.population || local_pop_growth < 0) {
              modifyValue(births, all_pops[i], local_pop_growth);
              modifyValue(births, "total", local_pop_growth);
            }
          }
        } else {
          if (!province_obj.pop_cap)
            province_obj.pop_cap = (config.defines.economy.rural_pop_cap) ?
              randomNumber(config.defines.economy.rural_pop_cap[0], config.defines.economy.rural_pop_cap[1]) :
              randomNumber(120000, 140000);

          //Calculate rural pop growth for all pops
          for (var i = 0; i < all_pops.length; i++) {
            if (province_obj.pops.population < province_obj.pop_cap) {
              var local_pop_growth = Math.ceil(province_obj.pops[all_pops[i]]*usr.pops[`${all_pops[i]}_growth_modifier`]*usr.modifiers.pop_growth_modifier) - province_obj.pops[all_pops[i]];

              modifyValue(births, all_pops[i], local_pop_growth);
              modifyValue(births, "total", local_pop_growth);
            }
          }
        }

    //Return statement
    return births;
  },

  /*
    getProvinceEducation() - Returns province education level object by percentage.
    options: {
      return_sum: true/false - Optional. Whether to return sum totals for each education level instead of percentages. False by default
    }
  */
  getProvinceEducation: function (arg0_province_id, arg1_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var educated_total = 0;
    var education_obj = {};
    var province_obj = main.provinces[province_id];

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("el_")) {
            var local_education_level = parseInt(all_pop_keys[i].replace("el_", ""));
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (!isNaN(local_education_level)) {
              modifyValue(education_obj, local_education_level, local_value);
              educated_total += local_value;
            }
          }

        modifyValue(education_obj, "0", province_obj.pops.population - educated_total, true);
      }

    //Standardise to percentage
    if (!options.return_sum)
      education_obj = standardisePercentage(education_obj, province_obj.pops.population);

    //Return statement
    return education_obj;
  },

  //getRelevantPops() - Returns an array of all pop keys with more than 0 population in a player country
  getRelevantPops: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_keys = Object.keys(config.pops);
    var relevant_pops = [];
    var usr = main.users[actual_id];

    //Iterate over all_pop_keys and check if usr.pops finds a match
    for (var i = 0; i < all_pop_keys.length; i++)
      if (usr.pops[all_pop_keys[i]]) {
        var local_pop = usr.pops[all_pop_keys[i]];
        var meets_conditions = true;

        //Global pop limit handling
        if (local_pop.disabled)
          meets_conditions = false;
        if (local_pop.industrial_pop)
          if (main.date.year < 1815)
            meets_conditions = false;

        if (meets_conditions)
          if (!relevant_pops.includes(all_pop_keys[i]))
            relevant_pops.push(all_pop_keys[i]);
      }

    //Return statement
    return relevant_pops;
  },

  getTotalActiveDuty: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var total_active_duty = 0;
    var usr = main.users[actual_id];

    //Fetch total active duty
    for (var i = 0; i < all_pops.length; i++)
      if (config.pops[all_pops[i]].military_pop)
        total_active_duty += usr.pops[`used_${all_pops[i]}`];

    //Return statement
    return total_active_duty;
  },

  getTotalPopConsumption: function (arg0_user, arg1_mode) {
    //Convert from parameters
    var user_id = arg0_user;
    var mode = arg1_mode; //"staple_goods", "luxury_goods"

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var consumption_obj = {};
    var usr = main.users[actual_id];

    //Iterate over all_pops for user and merge with consumption_obj
    for (var i = 0; i < all_pops.length; i++)
      try {
        var local_pop = config.pops[all_pops[i]];

        if (local_pop.per_100k)
          if (local_pop.per_100k.needs) {
            var total_pop_amount = returnSafeNumber(usr.pops[all_pops[i]]);
            var total_pop_needs = getPopNeeds(all_pops[i], total_pop_amount, mode);

            consumption_obj = mergeObjects(consumption_obj, total_pop_needs);
          }
      } catch (e) {
        log.warn(`${all_pops[i]} ran into an error whilst trying to fetch consumption_obj!`);
        console.log(e);
      }

    //Return statement
    return flattenObject(consumption_obj);
  },

  getTotalPopManpower: function (arg0_user, arg1_type, arg2_raw_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_raw_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var usr = main.users[actual_id];

    var availability_modifier = (pop_obj.military_pop) ?
      usr.modifiers.maximum_manpower*usr.modifiers.national_manpower
      : 1;

    //Return statement
    return (!raw_modifier) ? Math.ceil(usr.pops[pop_type]*availability_modifier) : availability_modifier;
  },

  //getUnemployedPops() - Returns the total unemployed pops of a given type in a province
  getUnemployedPops: function (arg0_province_id, arg1_type, arg2_no_subsistence) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var no_subsistence = arg2_no_subsistence;

    //Declare local instance variables
    var employed_pops = 0;
    var province_obj = main.provinces[province_id];

    var all_pop_keys = Object.keys(province_obj.pops);

    //Iterate over all_pop_keeps for wealth_ pools
    for (var i = 0; i < all_pop_keys.length; i++)
      if (all_pop_keys[i].startsWith("wealth-")) {
        var split_wealth_key = all_pop_keys[i].split("-");

        var local_pop_type = split_wealth_key[2];

        if (local_pop_type == pop_type) {
          var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
          var meets_conditions = true;

          if (no_subsistence && local_wealth_pool.subsistence)
            meets_conditions = false;

          if (meets_conditions)
            employed_pops += returnSafeNumber(local_wealth_pool.size);
        }
      }

    //Return statement
    return returnSafeNumber(province_obj.pops[all_pop_keys[i]] - employed_pops);
  },

  mergePopScopes: function (arg0_pop_scope, arg1_pop_scope) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var ot_pop_scope = arg1_pop_scope;

    //Declare local instance variables
    var all_ot_pop_scope_keys = Object.keys(ot_pop_scope);
    var all_ot_pop_scope_tags = Object.keys(ot_pop_scope.tags);
    var all_pop_scope_keys = Object.keys(pop_scope);
    var all_pop_scope_tags = Object.keys(pop_scope.tags);
    var contributing_totals = {}; //{ pop_scope: 851903, ot_pop_scope: 481822 }. Tracks ALL tag totals for each pop_scope compared to ot_pop_scope
    var new_pop_scope = {
      tags: {}
    };

    //Fetch set intersection of all_ot_pop_scope_tags and all_pop_scope_tags and push it to new_pop_scope.tags
    for (var i = 0; i < all_pop_scope_tags.length; i++) {
      var local_ot_value = ot_pop_scope.tags[all_pop_scope_tags[i]]; //Intersect operation
      var local_value = pop_scope.tags[all_pop_scope_tags[i]];

      if (local_value && local_ot_value) {
        var local_min_clamp = Math.min(local_ot_value, local_value);
        var local_total = local_value + local_ot_value;
        new_pop_scope.tags[all_pop_scope_tags[i]] = local_min_clamp;

        modifyValue(contributing_totals, "pop_scope", (local_value/local_total)*local_min_clamp);
        modifyValue(contributing_totals, "ot_pop_scope", (local_ot_value/local_total)*local_min_clamp);
      }
    }

    //Based on contributing_totals; merge top level key-values via weighted average. If counterpart is undefined, assume 0
    var contributing_total = contributing_totals.pop_scope + contributing_totals.ot_pop_scope;
    contributing_totals.pop_percentage = contributing_totals.pop_scope/contributing_total;
    contributing_totals.ot_pop_percentage = contributing_totals.ot_pop_scope/contributing_total;

    for (var i = 0; i < all_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }
    for (var i = 0; i < all_ot_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }

    //Return statement
    return new_pop_scope;
  },

  /*
    modifyEducationLevel() - Changes the education level of selected pops in a given province. [REVISIT] - Add pop selector options in the future.
    options: {
      province_id: "4407", - Which province ID should be targeted by this function?

      min: 0, - Optional. 0 by default. For which brackets should the education level be raised? (Lower bound)
      max: 0, - Optional. 1 by default. For which brackets should the education level be raised?

      capacity: 50000, - Optional. Entire province population by default. How many people should be raised in terms of education at a time?
      value: 0.05 - How much should education levels within these brackets up to capacity be modified?
    }
  */
  modifyEducationLevel: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var province_obj = main.provinces[options.province_id];
    var total_eligible = 0;

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        //Set defaults
        var max = Math.min(returnSafeNumber(options.max), 1);
        var min = Math.max(returnSafeNumber(options.min), 0);

        var capacity = (options.capacity) ? options.capacity : province_obj.pops.population;
        var value = returnSafeNumber(options.value);

        //Fetch education_profile_obj - lists current education profile; then standardise to percentages so that they can be moved up by their respective steps proportionally
        var education_profile_obj = {};
        var education_percentage_obj = {};

        //Iterate over all_pop_keys
        for (var i = 0; i < all_pop_keys.length; i++) {
          var local_value = province_obj.pops[all_pop_keys[i]];

          if (all_pop_keys[i].startsWith("el_")) {
            var local_key = all_pop_keys[i].replace("el_", "");
            var local_education_level = parseInt(local_key);

            if (local_education_level >= min && local_education_level <= max) {
              education_profile_obj[local_education_level] = local_value;
              total_eligible += local_value;
            }
          }
        }

        //Zero handler for total_eligible
        var uneducated_population = province_obj.pops.population - total_eligible;

        if (min <= 0)
          education_profile_obj[0] = uneducated_population;

        //Iterate over education_profile_obj to fetch education_percentage_obj
        var all_education_keys = Object.keys(education_profile_obj);

        for (var i = 0; i < all_education_keys.length; i++)
          education_percentage_obj[all_education_keys[i]] = education_profile_obj[all_education_keys[i]]/total_eligible;

        //Modify their actual education values now
        var new_keys = [];
        var rounding_overflow = 0;

        for (var i = 0; i < all_education_keys.length; i++) {
          var local_change = Math.ceil(capacity*education_percentage_obj[all_education_keys[i]]);
          var local_key = `el_${all_education_keys[i]}`;
          var new_value = parseInt(all_education_keys[i]) + Math.min(Math.ceil(value*100), 100);

          var new_key = `el_${new_value}`;

          if (local_change % 1 != 0) rounding_overflow++;

          modifyValue(province_obj.pops, local_key, local_change*-1);
          modifyValue(province_obj.pops, new_key, local_change);

          if (!new_keys.includes(new_key)) new_keys.push(new_key);

          //Clear useless keys
          if (province_obj.pops[local_key] <= 0)
            delete province_obj.pops[local_key];
          if (province_obj.pops[new_key] <= 0)
            delete province_obj.pops[new_key];
        }

        //Subtract rounding_overflow as much as possible
        for (var i = 0; i < new_keys.length; i++)
          if (rounding_overflow > 0) {
            var local_value = province_obj.pops[new_keys[i]];
            var value_removed = Math.min(local_value, rounding_overflow);

            modifyValue(province_obj.pops, new_keys[i], value_removed*-1);
            rounding_overflow -= value_removed;

            if (province_obj.pops[new_keys[i]] <= 0)
              delete province_obj.pops[new_keys[i]];
          }
      }
  },

  parsePops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);

    //Process pop objects
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      //Set icon values
      if (local_pop.icon) local_pop.icon = config.icons[local_pop.icon];
    }
  },

  /*
    processEmployment() - Processes the job market for a given pop type in a province
    options: {
      sorted_wage_obj: {}, - Optimisation parameter. The sorted wage object for the province.
      unemployed_pops: 3194 - Optimisation parameter. The total number of unemployed pops sitting in this province
    }
  */
  processEmployment: function (arg0_province_id, arg1_type, arg2_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var building_map = getBuildingMap(province_id);
    var province_obj = main.provinces[province_id];
    var unemployed_pops = (options.unemployed_pops) ? options.unemployed_pops : module.exports.getUnemployedPops(province_id, pop_type);

    //All unemployed pops are looking for a job
    if (province_obj)
      if (province_obj.buildings) {
        var building_wages = (options.sorted_wage_obj) ? options.sorted_wage_obj : getBuildingWages(province_id, pop_type);

        //Iterate over all_building_wages and select the range from the top of the current number of keys
        var all_building_wages = Object.keys(building_wages);
        var is_strict = config.defines.economy.strict_job_seeking;
        var job_seeking_range = config.defines.economy.job_seeking_range;

        var valid_building_range = [
          Math.floor(all_building_wages.length*job_seeking_range[0]),
          Math.floor(all_building_wages.length*job_seeking_range[1]) - 1
        ];
        valid_building_range.sort(function (a, b) { return a - b });

        for (var i = valid_building_range[1] - 1; i >= ((is_strict) ? valid_building_range[0] : 0); i++) {
          var building_id = all_building_wages[i];
          var local_building = province_obj.buildings[building_map[building_id]];
          var local_key = `wealth-${building_id}-${pop_type}`;

          //If they're currently hiring, take all the workers you can according to random_chance_roll. If positions max out, the unemployed_pops figure rolls over
          if (building_obj[`${pop_type}_positions`]) {
            var random_chance_roll = Math.random();
            var random_hirees = Math.floor(unemployed_pops*random_chance_roll);

            if (unemployed_pops > 0) {
              var available_positions = building_obj[`${pop_type}_positions`];

              if (available_positions > random_hirees) {
                building_obj[`${pop_type}_positions`] -= random_hirees;
                province_obj.pops[local_key].size += random_hirees;
                unemployed_pops -= random_hirees;
              } else {
                province_obj.pops[local_key].size += available_positions;
                unemployed_pops -= available_positions;

                //Delete building_obj[`${pop_type}_positions`] since all the positions have been hired
                delete building_obj[`${pop_type}_positions`];
              }
            }
          }
        }
      }
  },

  /*
    processPop() - Processes pop type per province
    options: {
      sorted_wage_obj: {} - Optimisation parameter. The sorted wage object for the province.
    }
  */
  processPop: function (arg0_province_id, arg1_type, arg2_options) { //[WIP] - Add pop growth/decline/needs/migration later
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var current_median = province_obj[`${pop_type}_median_wage`];
    var province_obj = main.provinces[province_id];

    //Pop Job Seeking and Employment
    {
      if (province_obj.buildings) {
        //Fetch remaining open positions
        var open_positions = 0;
        var total_job_seekers = 0;
        var unemployed_pops = module.exports.getUnemployedPops(province_id, pop_type);

        for (var i = 0; i < province_obj.buildings.length; i++) {
          var local_building = province_obj.buildings[i];

          open_positions += returnSafeNumber(local_building[`${pop_type}_positions`]);
        }

        //Remove unemployed_pops from open_positions
        open_positions -= unemployed_pops;

        //Iterate over province_obj.buildings and if the wages are now below current_median, pop types should seek new jobs if higher positions exist
        if (open_positions > 0)
          for (var i = 0; i < province_obj.buildings.length; i++) {
            var local_building = province_obj.buildings[i];

            if (local_building.employment)
              if (local_building[`${pop_type}_wage`]) {
                var current_wage = local_building[`${pop_type}_wage`];

                if (current_wage < current_median) {
                  var new_job_seekers = 1 - (current_wage/current_median);
                  new_job_seekers = Math.min(new_job_seekers, open_positions);

                  total_job_seekers += new_job_seekers;
                  layoffWorkers(local_building, pop_type, new_job_seekers);
                }
              }
          }

        //Process final employment both for those unemployed and those seeking a better job
        module.exports.processEmployment(province_id, pop_type, {
          sorted_wage_obj: options.sorted_wage_obj,
          unemployed_pops: unemployed_pops
        });
      }
    }
  },

  processPurchases: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var province_obj = main.provinces[province_id];

    if (province_obj)
      if (province_obj.pops) {
        var all_good_categories = Object.keys(config.defines.economy.good_categories);
        var all_pop_keys = Object.keys(province_obj.pops);

        //Iterate through all_pop_keys for wealth- starting keys
        for (var i = 0; i < all_pop_keys.length; i++)
          if (all_pop_keys[i].startsWith("wealth-")) {
            var current_allowance;
            var current_allowance_percentage;
            var local_percentage = local_wealth_pool.size/100000;
            var local_wealth_pool = province_obj.pops[all_pop_keys[i]];
            var spent_wealth = 0;
            var split_key = all_pop_keys[i].split("-");
            var pop_type = split_key[2];

            var pop_obj = config.pops[pop_type];

            //Initialise received_goods scope
            local_wealth_pool.received_goods = {};

            //Check pop_obj.per_100k.needs
            if (pop_obj.per_100k)
              if (pop_obj.per_100k.needs) {
                var category_buy_order = pop_obj.buy_order;
                var total_fulfilment = 0;
                var total_variety = 0;

                for (var x = 0; x < category_buy_order.length; x++)
                  local_wealth_pool.received_goods[category_buy_order[x]] = {};

                for (var x = 0; x < all_good_categories.length; x++) {
                  var local_good_category = config.defines.economy.good_categories[all_good_categories[x]];
                  current_allowance_percentage = returnSafeNumber(local_good_category.importance, 1);
                  current_allowance = local_wealth_pool.income*current_allowance_percentage;

                  //Iterate over category_buy_order and local needs groups to buy everything in lookup.goods_type[all_good_categories[x]]
                  for (var y = 0; y < category_buy_order.length; y++) {
                    var local_buy_order = pop_obj[`${category_buy_order[y]}-buy_order`];
                    var local_category = pop_obj.per_100k.needs[category_buy_order[y]];
                    var local_received_goods = local_wealth_pool.received_goods[category_buy_order[y]];

                    for (var z = 0; z < local_buy_order.length; z++)
                      if (spent_wealth < local_wealth_pool.income) {
                        //Begin buying as many goods as needed for this wealth pool size
                        var local_market_good = main.market[local_buy_order[z]]
                        var local_value = local_category[local_buy_order[z]];

                        //Spend money on good
                        if (local_market_good) {
                          var local_need = Math.ceil(local_value*local_percentage);

                          var actual_consumption = Math.min(getGoodAmount(user_id, local_buy_order[z]), local_need);
                          var local_worth = actual_consumption*local_market_good.buy_price;

                          spent_wealth += local_worth;
                          modifyValue(local_received_goods, local_buy_order[z], actual_consumption);
                        }
                      }
                  }
                }

                //Subtract spent_wealth from wealth pool
                local_wealth_pool.wealth -= spent_wealth;
                local_wealth_pool.spending = spent_wealth;

                //Update _fulfilment and _variety for each category
                for (var x = 0; x < category_buy_order.length; x++) {
                  var local_received_goods = local_wealth_pool.received_goods[category_buy_order[x]];

                  var local_fulfilment_obj = module.exports.getPopNeedsFulfilment(local_received_goods, pop_type, local_wealth_pool.size, {
                    needs_category: category_buy_order[x],
                    return_object: true
                  });
                  total_fulfilment += local_fulfilment_obj.fulfilment;
                  total_variety += local_fulfilment_obj.variety;

                  //Set local fulfilment and variety
                  local_wealth_pool[`${category_buy_order[x]}-fulfilment`] = local_fulfilment_obj.fulfilment;
                  local_wealth_pool[`${category_buy_order[x]}-variety`] = local_fulfilment_obj.variety;
                }

                //Set general fulfilment and variety
                local_wealth_pool.fulfilment = total_fulfilment/category_buy_order.length;
                local_wealth_pool.variety = total_variety/category_buy_order.length;
              }
          }
      }
  },

  //processPops() - Processes all pops in a given province
  processPops: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var province_obj = main.provinces[province_id];

    //Iterate over all pops and process them
    for (var i = 0; i < all_pops.length; i++) {
      //Initialise local tracker variables
      var local_sorted_wages = getBuildingWages(province_id, all_pops[i]);
      var median_wage = getMedianWage(province_id, {
        pop_type: all_pops[i],
        building_wage_obj: local_sorted_wages
      });

      //Set trackers
      province_obj[`${all_pops[i]}_median_wage`] = median_wage;

      processPop(province_id, all_pops[i], {
        sorted_wage_obj: local_sorted_wages
      });
    }
  },

  /*
    removePop() - Removes pops from a province
    options: See selectPops(), additional options: {
      amount: 50000 - The amount of pops to remove
    }
  */
  removePop: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var killed = 0;
    var pop_scope = module.exports.selectPops(options);
    var province_obj = main.provinces[options.province_id];
    var usr = main.users[actual_id];

    //Subtract population
    if (province_obj)
      if (province_obj.pops[options.pop_type]) {
        var building_key_map = (options.building_key_map) ? options.building_key_map : getBuildingMap(options.province_id);

        if (pop_scope.size > 0) {
          var all_tags = Object.keys(pop_scope.tags);
          var scalar = 1;

          if (options.amount < pop_scope.size)
            scalar = options.amount/pop_scope.size;

          //Remove all tags; lay off those in wealth pools
          for (var i = 0; i < all_tags.length; i++) {
            var local_value = Math.floor(pop_scope.tags[all_tags[i]]*scalar);

            if (all_tags[i].startsWith("wealth-")) {
              var split_key = all_tags[i].split("-");

              var building_id = split_key[1];
              var local_building = province_obj.buildings[building_key_map[building_id]];
              var local_pop_type = split_key[2];

              if (local_building)
                layoffWorkers(local_building, local_pop_type, local_value);
            } else {
              modifyValue(province_obj.pops, all_tags[i], local_value*-1, true);
            }
          }

          //Set killed
          killed = Math.floor(scalar*pop_scope.size);
        }

        if (options.pop_type)
          if (!province_obj.pops[options.pop_type])
            province_obj.pops[options.pop_type] = 0;
        if (!province_obj.pops.population)
          province_obj.pops.population = 0;
      }

    //Return statement
    return killed;
  },

  /*
    removePops() - Kills a certain number of pops from a user based on the available options.
    options: {
      migration: true/false, - Whether the pops migrated or not instead of being killed. False by default
      provinces: ["6709", "6710"], - A list of provinces to target for removing pops. All of a user's provinces by default
      type: "soldiers", - Which type of pop to kill off
      amount: 10000 - How much of the pop to kill off
    }
  */
  removePops: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = arg1_options;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var decimation_obj = {};
    var pop_obj = config.pops[options.type];
    var pop_types = getList(options.type);
    var remaining_population = returnSafeNumber(options.amount);
    var shuffled_provinces = shuffleArray(getProvinces(user_id));
    var usr = main.users[actual_id];

    var target_provinces = (options.provinces) ? getList(options.provinces) : shuffled_provinces;

    //Parse 'all' argument as well
    pop_types = (pop_types.includes("all")) ? Object.keys(config.pops) : pop_types;

    //Assign decimation_array to decimation_obj
    var decimation_array = splitNumber(1, pop_types.length);

    for (var i = 0; i < pop_types.length; i++)
      decimation_obj[pop_types[i]] = decimation_array[i];

    //Begin subtracting pops
    for (var i = 0; i < pop_types.length; i++) {
      var amount_to_remove = decimation_obj[pop_types[i]];
      var total_pops = 0;

      //Sum up total_pops from target_provinces
      for (var x = 0; x < target_provinces.length; x++) {
        var local_province = main.provinces[target_provinces[x]];

        if (local_province.pops)
          if (local_province.pops[pop_types[i]])
            total_pops += local_province.pops[pop_types[i]];
      }

      var total_pop_percentage = returnSafeNumber(amount_to_remove/total_pops);

      //Subtract local_province.pops[pop_types[i]]*total_pop_percentage from each city
      for (var x = 0; x < target_provinces.length; x++) {
        var local_province = main.provinces[target_provinces[x]];
        var local_removed_pops = module.exports.removePop(user_id, {
          province_id: target_provinces[x],

          pop_type: pop_types[i],
          amount: local_province.pops[pop_types[i]]*total_pop_percentage
        });

        decimation_obj[pop_types[i]] -= local_removed_pops;
      }
    }

    //Add to civilian/military casualties tracker
    if (!options.migration)
      if (!getList(options.type).includes("all")) {
        if (pop_obj.military_pop) {
          usr.recent_military_casualties[usr.recent_military_casualties.length - 1] += options.amount;
        } else {
          usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += options.amount;
        }
      } else {
        usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += options.amount;
      }

    //Return statement
    return decimation_obj;
  },

  /*
    selectPops() - Merges pops based on a pop's characteristics and given frequency distributions according to proportionality.
    options: {
      province_id: "4707", - The province ID to merge pops from. Required

      building_ids: [], - A given list of building ID's to select employed pops from
      education_level: { - Optional. Undefined by default
        min: 0,
        max: 1,
        mean: 0.50 - Optional. Midpoint by default
      },
      education_level_less_than: 0.50, - Optional. Undefined by default.
      employed: true/false, - Optional. Whether the pop is employed or not. False by default
      empty: true/false, - Optional. Whether to return an empty pop scope. False by default
      has_accepted_culture: true/false, - Optional. Restricts pops to accepted cultures only
      has_<goods_category>: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      has_<goods_category>_variety: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      homeless: true/false, - Optional. Whether the pop is currently homeless. Undefined by default
      income: 500, - Optional. What income levels should be targeted in scope. Undefined by default
      income_less_than: 250, - Optional. What income levels should be targeted in scope. Undefined by default
      is_employed: true/false, - Optional. Whether the pop should be employed or not. Undefined by default
      pop_types: [], - A given list of pop types to return a single pop from. Returns all pops by default
      wealth: 40000, - Optional. What their wealth should be above or equal to
      wealth_less_than: 20000 - Optional. What their wealth should be below or equal to
    }

    Returns: {
      size: 4407, - The size of the pop that meets the aforementioned categories
      income: 0, - Their relative income last turn. All metrics given in weighted averages
      wealth: 0, - Their current wealth

      staple_goods-fulfilment: 0.86, - Category specific fulfilment and variety
      staple_goods-variety: 0.60,
      ..

      fulfilment: 0.67, - General fulfilment and variety
      variety: 0.15,
      ..

      //Key-value pairings that would be selected from this merge pop scope
      tags: {
        labourers: 4407,
        engineers: 2202,
        used_engineers: 1105,
        ..

        wealth-<building_id>-<pop_type>: 2505
      }
    }
  */
  selectPops: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var current_scope = {
      size: 0,
      income: 0,
      wealth: 0,

      tags: {}
    };
    var goods_fulfilment_selectors = {};
    var goods_variety_selectors = {};
    var province_id = options.province_id;
    var province_obj = main.provinces[province_id];

    //Initialise defaults for variables
    var selected_pops = (options.pop_types) ? options.pop_type : Object.keys(config.pops);

    if (province_obj.pops && !options.empty) {
      var all_cultures = getList(options.culture);
      var all_pop_keys = Object.keys(province_obj.pops);
      var max_selected = {};

      //Optimise dynamic selectors (has_<goods_category>, has_<goods_category>_variety, etc.)
      {
        var all_options = Object.keys(options);

        if (options.is_employed)
          options.employed = options.is_employed;
        for (var i = 0; i < all_options.length; i++) {
          var local_value = options[all_options[i]];

          if (all_options[i].startsWith("has_")) { //has_<goods_category>
            var goods_category_name = all_options[i].replace("has_", "");

            if (lookup.all_pop_needs_categories.includes(goods_category_name))
              goods_fulfilment_selectors[all_options[i]] = local_value;
          }
          if (all_options[i].startsWith("has_")) { //has_<goods_category>_variety
            var goods_category_name = all_options[i].replace("has_", "").replace("_variety", "");

            if (lookup.all_pop_needs_categories.includes(goods_category_name))
              goods_variety_selectors[all_options[i]] = local_value;
          }
        }

        var all_goods_fulfilment_keys = Object.keys(goods_fulfilment_selectors);
        var all_goods_variety_keys = Object.keys(goods_variety_selectors);
      }

      //Initial block processing for province-level characteristics
      {
        var accepted_culture_scalar = 1,
          accepted_culture_total = 0;
        var culture_scalar = 1,
          culture_total = 0;
        var education_obj = {},
          education_scalar = 1,
          education_total = 0;
        var education_less_than_obj = {},
          education_less_than_scalar = 1,
          education_less_than_total = 0;
        var homeless_scalar = 1;

        if (options.culture) {
          for (var i = 0; i < all_pop_keys.length; i++) {
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (all_pop_keys[i].startsWith("culture-")) {
              var culture_id = all_pop_keys[i].replace("culture-", "");
              var local_culture = main.global.cultures[culture_id];

              if (all_cultures.includes(culture_id)) {
                current_scope.tags[all_pop_keys[i]] = local_value;
                culture_total += local_value;
              }
            }
          }

          culture_scalar = culture_total/province_obj.pops.population;
        }
        if (options.education_level) { //Education selector
          var max = returnSafeNumber(options.education_level.max, 1);
          var min = returnSafeNumber(options.education_level.min, 0);

          if (!options.education_level.mean) {
            for (var i = 0; i < all_pop_keys.length; i++) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              if (all_pop_keys[i].startsWith("el_")) {
                var education_level = parseInt(local_value.replace("el_", ""));

                if (education_level >= min*100 && education_level <= max*100) {
                  education_obj[`el_${education_level}`] = local_value;
                  education_total += local_value;
                }
              }
            }
          } else {
            var mean = returnSafeNumber(options.education_level.mean);

            var education_distribution = pearsonVIIDistribution(100, mean, min, max, {
              key_name: "el"
            });
            var all_education_distribution_keys = Object.keys(education_distribution);

            for (var i = 0; i < all_education_distribution_keys.length; i++) {
              var local_amount = education_distribution[all_education_distribution_keys[i]];
              var local_education_amount = returnSafeNumber(province_obj.pops[all_education_distribution_keys[i]]);
              var local_value = local_education_amount*local_amount;

              education_obj[all_education_distribution_keys[i]] = local_value;
              education_total += local_value;
            }
          }

          education_scalar = education_total/province_obj.pops.population;
        }
        if (options.education_level_less_than) {
          for (var i = 0; i < all_pop_keys.length; i++) {
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (all_pop_keys[i].startsWith("el_")) {
              var education_level = parseInt(local_value.replace("el_", ""));

              if (education_level < options.education_level_less_than*100) {
                education_less_than_obj[`el_${education_level}`] = local_value;
                education_less_than_total += local_value;
              }
            }
          }

          education_less_than_scalar = education_less_than_total/province_obj.pops.population;
        }
        if (options.has_accepted_culture) {
          for (var i = 0; i < all_pop_keys.length; i++) {
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (all_pop_keys[i].startsWith("culture-")) {
              var culture_id = all_pop_keys[i].replace("culture-", "");
              var local_culture = main.global.cultures[culture_id];

              if (
                culture_obj.primary_culture.includes(province_obj.controller) ||
                culture_obj.accepted_culture.includes(province_obj.controller)
              ) {
                current_scope.tags[all_pop_keys[i]] = local_value;
                accepted_culture_total += local_value;
              }
            }
          }

          accepted_culture_scalar = accepted_culture_total/province_obj.pops.population;
        }
        if (options.homeless != undefined) //Homeless selector
          homeless_scalar = (options.homeless) ?
            returnSafeNumber(province_obj.housing)/province_obj.pops.population :
            1 - returnSafeNumber(province_obj.housing)/province_obj.pops.population;
      }

      //Iterate over all_pop_keys
      for (var i = 0; i < all_pop_keys.length; i++) {
        var explicitly_defined = false;
        var local_subobj = province_obj.pops[all_pop_keys[i]];
        var meets_conditions = true;

        var attribute_type = "";
        var building_id = "";
        var is_employed = false;
        var local_pop_type = "";

        //Initialise tracker variables
        {
          if (lookup.all_pops[all_pop_keys[i]])
            local_pop_type = all_pop_keys[i];
          if (all_pop_keys[i].startsWith("used_")) {
            is_employed = true;
            local_pop_type = all_pop_keys[i].replace("used_", "");
          }
          if (all_pop_keys[i].startsWith("wealth_")) {
            var split_wealth_key = all_pop_keys[i].split("-");

            building_id = split_wealth_key[1];
            is_employed = true;
            local_pop_type = split_wealth_key[2];
          }
        }

        //Check if this is explicitly defined
        {
          //culture
          if (all_pop_keys[i].startsWith("culture-")) {
            if (all_cultures.length > 0)
              attribute_type = "culture";
          }

          //education_level - NO PARSING because already handled in block processing

          //employed
          if (all_pop_keys[i].startsWith("used_")) {
            if (options.is_employed != undefined)
              attribute_type = "employed";
          }

          //wealth_pool
          if (all_pop_keys[i].startsWith("wealth-"))
            if (
              options.income != undefined ||
              options.income_less_than != undefined ||
              options.wealth != undefined ||
              options.wealth_less_than != undefined
            )
              attribute_type = "wealth_pool";
        }

        //Check if local_subobj meets conditions
        {
          if (!selected_pops.includes(local_pop_type)) //Pop selector
            meets_conditions = false;

          if (options.building_ids) //Building selector
            if (!options.building_ids.includes(building_id))
              meets_conditions = false;
          if (all_pop_keys[i].startsWith("culture-")) //Culture selector
            if (all_cultures.length > 0) {
              var culture_id = all_pop_keys[i].replace("culture-", "");

              if (!all_cultures.includes(culture_id))
                meets_conditions = false;
            }
          if (options.education_level) //Education level selector, no new parsing since it was handled in initial block processing
            if (all_pop_keys[i].startsWith("el_"))
              meets_conditions = false;

          if (options.employed != undefined) //Employment selector
            if (options.employed) {
              if (!is_employed)
                meets_conditions = false;
            } else {
              if (is_employed)
                meets_conditions = false;
            }
          if (all_pop_keys[i].startsWith("wealth-")) { //Wealth pool handler
            for (var i = 0; i < all_goods_fulfilment_keys.length; i++) {
              var local_category_name = all_goods_fulfilment_keys[i].replace("has_", "");
              var local_value = goods_fulfilment_selectors[all_goods_fulfilment_keys[i]];

              if (local_subobj[`${local_category_name}-fulfilment`] < local_value)
                meets_conditions = false;
            }
            for (var i = 0; i < all_goods_variety_keys.length; i++) {
              var local_category_name = all_goods_variety_keys[i].replace("has_", "").replace("_variety", "");
              var local_value = goods_variety_selectors[all_goods_variety_keys[i]];

              if (local_subobj[`${local_category_name}-variety`] < local_value)
                meets_conditions = false;
            }
            if (options.income)
              if (local_subobj.income < options.income)
                meets_conditions = false;
            if (options.income_less_than)
              if (local_subobj.income >= options.income_less_than)
                meets_conditions = false;
            if (options.wealth)
              if (local_subobj.wealth < options.wealth)
                meets_conditions = false;
            if (options.wealth_less_than)
              if (local_subobj.wealth >= options.wealth_less_than)
                meets_conditions = false;
          }
        }

        //Append to current_scope if meets_conditions
        if (meets_conditions) {
          //Set max_selected pops for post-scalar later down the road
          if (attribute_type != "")
            if (typeof local_subobj == "number") {
              modifyValue(max_selected, attribute_type, local_subobj);
            } else if (typeof local_subobj == "object") {
              if (attribute_type == "wealth")
                modifyValue(max_selected, "wealth", local_subobj.size);
            }

          //Normal key handler
          {
            if (lookup.all_pops[all_pop_keys[i]]) {
              modifyValue(current_scope.tags, all_pop_keys[i], local_subobj);
              current_scope.size = Math.max(current_scope.size, local_subobj);
            }
            if (all_pop_keys[i].startsWith("used_")) {
              modifyValue(current_scope.tags, all_pop_keys[i], local_subobj);
              current_scope.size = Math.max(current_scope.size, local_subobj);
            }
          }

          //Wealth pool handler
          {
            //Subtract unapplicable stats from current_scope (e.g. Pop need fulfilment)
            if (all_pop_keys[i].startsWith("wealth-")) {
              var all_wealth_keys = Object.keys(local_subobj);

              current_scope.size += local_subobj.size;
              modifyValue(current_scope.tags, all_pop_keys[i], local_subobj.size);

              //Income, wealth, and fulfilment/variety handlers
              current_scope.income += local_subobj.income;
              current_scope.wealth += local_subobj.wealth;

              for (var i = 0; i < all_wealth_keys.length; i++) {
                var local_obj = local_subobj[all_wealth_keys[i]];

                if (
                  all_wealth_keys[i].includes("-fulfilment") ||
                  all_wealth_keys[i].includes("-variety")
                )
                  modifyValue(current_scope, all_wealth_keys[i], local_subobj.size*local_obj);
                if (["fulfilment", "variety"].includes(all_wealth_keys[i]))
                  modifyValue(current_scope, all_wealth_keys[i], local_subobj.size*local_obj);
              }
            }
          }
        }
      }

      //Normalise total fulfilment and variety keys in current_scope
      var all_max_selected = Object.keys(max_selected);
      var all_scope_keys = Object.keys(current_scope);
      var all_tags = Object.keys(current_scope.tags);

      //tag_scalar handler
      {
        var max_selected = 0;

        for (var i = 0; i < all_max_selected.length; i++)
          max_selected = Math.max(max_selected, max_selected[all_max_selected[i]]);

        var tag_scalar = (max_selected < current_scope.size) ?
          max_selected/current_scope.size : current_scope.size/max_selected; //[WIP] - Doubt this post-scalar treatment works but we'll see if it does
      }

      //province_scalar handler
      {
        var province_scalar =
          accepted_culture_scalar*culture_scalar*education_scalar*education_less_than_scalar*homeless_scalar
          *tag_scalar; //Tag scalar so that the selected tags can't be greater than current_scope.size

        current_scope.size = current_scope*province_scalar;
        current_scope.income = current_scope*province_scalar;
        current_scope.wealth = current_scope*province_scalar;

        for (var i = 0; i < all_tags.length; i++) {
          var local_value = current_scope.tags[all_tags[i]];

          current_scope.tags[all_tags[i]] = local_value*province_scalar;
        }
      }

      //Iterate over various objects to add to tags
      current_scope.tags = mergeObjects(current_scope.tags, education_obj);
      current_scope.tags = mergeObjects(current_scope.tags, education_less_than_obj);

      for (var i = 0; i < all_scope_keys.length; i++) {
        var local_value = current_scope[all_scope_keys[i]];

        if (
          all_scope_keys[i].includes("-fulfilment") ||
          all_scope_keys[i].includes("-variety")
        )
          current_scope[all_scope_keys[i]] = local_value/current_scope.size;
        if (["fulfilment", "variety"].includes(all_scope_keys[i]))
          current_scope[all_scope_keys[i]] = local_value/current_scope.size;
      }

      //Override tags - KEEP AT BOTTOM!
      current_scope.tags.population = current_scope.size;
    }

    //Return statement
    return current_scope;
  }
};
