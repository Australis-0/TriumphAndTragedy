module.exports = {
  addPopScopes: function (arg0_pop_scope, arg1_pop_scope) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var ot_pop_scope = arg1_pop_scope;

    //Declare local instance variables
    var all_ot_pop_scope_keys = Object.keys(ot_pop_scope);
    var all_ot_pop_scope_tags = Object.keys(ot_pop_scope.tags);
    var sum_size = pop_scope.size + ot_pop_scope.size;

    var from_scalar = ot_pop_scope.size/sum_size;
    var to_scalar = pop_scope.size/sum_size;

    //Weighted average top-level attributes. Exclude wealth/size
    for (var i = 0; i < all_ot_pop_scope_keys.length; i++)
      if (!reserved.pop_scope_sum_keys.includes(all_ot_pop_scope_keys)) {
        var local_value = pop_scope[all_ot_pop_scope_keys[i]];
        var local_ot_value = ot_pop_scope[all_ot_pop_scope_keys[i]];

        if (typeof local_ot_value == "number")
          if (pop_scope[all_ot_pop_scope_keys[i]]) {
            //Weight by size
            var from_factor = local_value*from_scalar;
            var to_factor = local_ot_value*to_scalar;

            pop_scope[all_ot_pop_scope_keys[i]] = Math.ceil((from_factor + to_factor)/2);
          } else {
            //Not there, set to pop_scope
            pop_scope[all_ot_pop_scope_keys[i]] = local_value;
          }
      }

    //Add wealth, size
    pop_scope.size = sum_size;
    pop_scope.wealth = pop_scope.wealth + ot_pop_scope.wealth;

    //Merge tags
    pop_scope.tags = mergeObjects(pop_scope, ot_pop_scope);

    //Return statement
    return pop_scope;
  },

  /*
    createPops() - Generates a certain number of pops for a given province with standard rolling. [WIP] - Add ability for pops to be generated by scope later
    options: {
      initialise: true/false, - Optional. Whether Pops are being initialised (create actual age distribution). False by default
      new_turn: true, - Optional. Whether pops are being created on a new turn. False by default.

      age: {
        min: 0,
        max: 120,
        mean: 60 - Optional. Midpoint by default
      },
      age: 45, - Exclusive with the above arguments
      culture: ["09418904328"], - Optional. The IDs of the culture to generate pops for. Undefined by default. Can also be object of percentage values: { "09418904328": 1.00  }
      education_level: { - Optional. Undefined by default
        min: 0,
        max: 1,
        mean: 0.50 - Optional. Midpoint by default
      },
      tags: {}, - Adds certain tags to the end province. Used typically for transferring pops
      type: "all"/["workers", "soldiers"] - Optional. Chooses the types of pops to generate. All by default
      amount: 100000 - How many pops should be generated in the given province
    }
  */
  createPops: function (arg0_province, arg1_options) {
    //Convert from parameters
    var province_obj = getProvince(arg0_province);
    var options = (arg1_options) ? arg1_options : {};

    //Initialise default options values
    options.type = (!options.type) ? ["all"] : getList(options.type);

    //Declare local instance variables
    var all_pops = (options.type.includes("all")) ?
      Object.keys(config.pops) :
      options.type;
    var old_population = (province_obj.pops) ? JSON.parse(JSON.stringify(province_obj.pops)) : {};
    var relevant_pops = getRelevantPops(user_id); //Returns pop key list
    var usr = (province_obj) ? main.users[province_obj.controller] : undefined;

    //Regular error trapping
    try {
      //Remove old user population so that it can be 'reset' to accomodate the new one
      usr.population -= province_obj.population;

      //Generate pops similar to settle_province.js
      var population_cache = options.amount;
      if (!province_obj.pops) {
        province_obj.pops = {};
      } else {
        //Temporary fix
        standardiseAttributes(province_obj.id, "age");
        standardiseAttributes(province_obj.id, "culture");
      }

      //Generate all pops through chance
      var pop_chances = {}; //Standardise sum to 1

      for (var i = 0; i < relevant_pops.length; i++) {
        var local_pop = config.pops[relevant_pops[i]];

        if (local_pop.chance) {
          var random_percentage = randomNumber((local_pop.chance*100)/2, (local_pop.chance*100)*2, true);

          pop_chances[relevant_pops[i]] = random_percentage;
        }
      }

      log.debug(`Pop Chances: `, pop_chances);

      pop_chances = standardisePercentage(pop_chances);
      var all_pop_chances = Object.keys(pop_chances);
      var culture_percentages = getProvinceCulture(province_obj.id);
      var population = getProvincePopulation(province_obj.id);

      var all_cultures = Object.keys(culture_percentages);

      //Partition pops in pop_chances
      for (var i = 0; i < all_pop_chances.length; i++) {
        var local_chance = pop_chances[all_pop_chances[i]];
        var population_change = parseInt(options.amount*local_chance);

        //Undefined pops save space in the DB
        modifyValue(province_obj.pops, all_pop_chances[i], population_change);

        //Distribute age
        if (!options.age) {
          if (options.initialise) {
            //Distribute them according to simple Leslie Matrix distribution
            var oefr = 0;
            var pop_fertile_women = getProvinceFertileWomen(province_obj.id);
            var pop_growth_modifier = returnSafeNumber(usr.modifiers.pop_growth_modifier, 1);
            var pop_percentage = 0;

            for (var x = 0; x < all_pops.length; x++) {
              var local_value = returnSafeNumber(province_obj.pops[all_pops[x]]);

              oefr += returnSafeNumber(getPopOEFR(province_obj.id, all_pops[x]));
              pop_percentage += returnSafeNumber(local_value/population);
            }
            if (oefr == 0) oefr = config.defines.economy.base_oefr; //Base initialisation OEFR

            oefr = oefr/all_pops.length;
            var pop_fertility = oefr*pop_growth_modifier;

            //Generate simple Leslie Matrix
            var leslie_matrix = leslieMatrixSimple(pop_fertility, population_change, config.defines.economy.old_age_hard_upper_bound);

            var all_leslie_matrix_keys = Object.keys(leslie_matrix.cohorts);

            //Add b_<year> by all_leslie_matrix_keys
            for (var x = 0; x < all_leslie_matrix_keys.length; x++) {
              var age = parseInt(all_leslie_matrix_keys[x]);
              var birth_year = main.date.year - age;
              var local_value = leslie_matrix.cohorts[all_leslie_matrix_keys[x]];

              if (local_value > 0)
                modifyValue(province_obj.pops, `b_${birth_year}`, Math.floor(local_value));
            }
          } else {
            options.age = 0; //It needs to be something
          }
        } else {
          if (typeof options.age == "object") {
            var current_year = main.date.year;
            var max = returnSafeNumber(options.age.max, config.defines.economy.old_age_hard_upper_bound);
            var min = returnSafeNumber(options.age.min, 0);

            var domain = Math.abs(max - min);

            if (!options.education_level.mean) {
              //If there's no mean, assume equal distribtuion
              var local_percentage = 1/domain;

              for (var x = 0; x < max; x++)
                modifyValue(province_obj.pops, `b_${Math.floor(current_year)}`, Math.floor(population_change*local_percentage));
            } else {
              var age_distribution = pearsonVIIDistribution(domain, options.age.mean, min, max);
              var all_age_distribution_keys = Object.keys(age_distribution);

              for (var x = 0; x < all_age_distribution_keys.length; x++) {
                var local_percentage = age_distribution[all_age_distribution_keys[x]];

                modifyValue(province_obj.pops, `b_${parseInt(all_age_distribution_keys[x]) + min}`, Math.floor(population_change*local_percentage));
              }
            }
          } else {
            if (options.new_turn) {
              var turn_years = parseInt(1/getTimeModifier());

              for (var x = 0; x < turn_years; x++) {
                var local_percentage = 1/turn_years;

                modifyValue(province_obj.pops, `b_${main.date.year + x}`, Math.floor(population_change*local_percentage));
              }
            } else {
              modifyValue(province_obj.pops, `b_${main.date.year}`, Math.floor(population_change));
            }
          }
        }

        //Distribute cultures proportionally
        if (!options.culture) {
          for (var x = 0; x < all_cultures.length; x++)
            modifyValue(province_obj.pops, `culture-${all_cultures[x]}`, population_change*Math.floor(culture_percentages[all_cultures[x]]));
        } else {
          if (typeof options.culture != "object") {
            var adjusted_percentages = {};
            var culture_list = getList(options.culture);
            var percentage_total = 0;

            for (var x = 0; x < culture_list.length; x++)
              adjusted_percentages[culture_list[x]] = returnSafeNumber(culture_percentages[culture_list[x]]);
            adjusted_percentages = standardisePercentage(adjusted_percentages);

            for (var x = 0; x < culture_list.length; x++)
              modifyValue(province_obj.pops, `culture-${culture_list[x]}`, population_change*Math.floor(culture_percentages[all_cultures[x]]));
          } else {
            var adjusted_percentages = standardisePercentage(options.culture);
            var all_specified_cultures = Object.keys(adjusted_percentages);

            for (var x = 0; x < all_specified_cultures.length; x++)
              modifyValue(province_obj.pops, `culture-${all_specified_cultures[x]}`, population_change*Math.floor(adjusted_percentages[all_specified_cultures[x]]));
          }
        }

        //Distribute education level if specified
        if (options.education_level) { //0 education by default - newborns can't read!
          var max = returnSafeNumber(options.education_level.max, 1);
          var min = returnSafeNumber(options.education_level.min, 0);

          if (!options.education_level.mean) {
            //If there's no mean, assume equal distribution
            var local_percentage = 1/Math.abs(max - min);

            for (var x = min; x < max; x++)
              modifyValue(province_obj.pops, `el_${Math.floor(x*100)}`, population_change*local_percentage);
          } else {
            var education_distribution = pearsonVIIDistribution(100, options.education_level.mean, min, max, {
              key_name: "el"
            });
            var all_education_distribution_keys = Object.keys(education_distribution);

            for (var x = 0; x < all_education_distribution_keys.length; x++) {
              var local_percentage = education_distribution[all_education_distribution_keys[x]];

              modifyValue(province_obj.pops, all_education_distribution_keys[x], population_change*local_percentage);
            }
          }
        }
      }


      //Calculate new total population of province and add it to user tracker variables
      {
        var all_local_pops = Object.keys(province_obj.pops);
        var total_population = 0;

        for (var i = 0; i < all_local_pops.length; i++)
          if (config.pops[all_local_pops[i]]) {
            var local_value = province_obj.pops[all_local_pops[i]];

            usr.pops[all_local_pops[i]] += local_value;
            total_population += returnSafeNumber(local_value);
          }
      }

      //Process tags
      if (options.tags) {
        var all_tags = Object.keys(options.tags);

        for (var i = 0; i < all_tags.length; i++)
          modifyValue(province_obj.pops, all_tags[i], options.tags[all_tags[i]]);
      }

      //Add total_population back to usr.population and province tracker
      province_obj.pops.population = total_population;
      usr.population += total_population;
    } catch (e) {
      log.error(`createPops() ran into an error: ${e}.`);
      console.log(e);
    }
  },

  fixProvinces: function (arg0_user, arg1_provinces) {
    //Convert from parameters
    var user_id = arg0_user;
    var provinces = (arg1_provinces) ? getList(arg1_provinces) : getProvinces(user_id, { include_occupations: true, return_keys: true });

    //Iterate over all provinces
    for (var i = 0; i < provinces.length; i++) {
      var local_province = getProvince(provinces[i]);
        local_province = main.provinces[local_province.id];

      //Standardise atttributes
      standardiseAttributes(local_province, "age");
      standardiseAttributes(local_province, "culture");

      if (local_province.pops) {
        var all_pop_keys = Object.keys(local_province.pops);

        //Fix wealth pools
        for (var x = 0; x < all_pop_keys.length; x++) {
          var local_value = local_province.pops[all_pop_keys[x]];

          if (all_pop_keys[x].startsWith("wealth-"))
            if (!all_pop_keys[x].includes("subsistence"))
              if (!local_value.size) //If size is 0 or undefined
                delete local_province.pops[all_pop_keys[x]];
        }
      }

      local_province.pops.population = getProvincePopulation(local_province.id);
    }
  },

  getArtisanPops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var artisan_pops = [];

    //Iterate over all_pops
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.artisan_pop)
        artisan_pops.push(all_pops[i]);
    }

    //Return statement
    return artisan_pops;
  },

  getPopClasses: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var class_obj = {};

    //Iterate over all_pops in config and append unique classes to class_obj
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      if (local_pop.class) {
        if (!class_obj[local_pop.class]) class_obj[local_pop.class] = [];
        class_obj[local_pop.class].push(all_pops[i]);
      }
    }

    //Return statement
    return class_obj;
  },

  getPopModifier: function (arg0_user, arg1_type, arg2_modifier) {
    //Convert from parameters
    var user_id = arg0_user;
    var pop_type = arg1_type;
    var raw_modifier = arg2_modifier;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var pop_obj = config.pops[pop_type];
    var total_modifier = 0;
    var total_pop_type = getTotalPopManpower(user_id, pop_type);
    var usr = main.users[actual_id];

    //Regular error trapping just in case the specified modifier does not exist
    try {
      //Calculate total_modifier
      if (pop_obj.per_100k)
        if (pop_obj.per_100k[raw_modifier])
          total_modifier = (total_pop_type/100000)*pop_obj.per_100k[raw_modifier];

      //Make sure to implement a proper cap
      if (pop_obj.max_modifier_limit)
        if (pop_obj.max_modifier_limit[raw_modifier])
          if (total_modifier > pop_obj.max_modifier_limit[raw_modifier])
            total_modifier = pop_obj.max_modifier_limit[raw_modifier];

      //Return statement
      return total_modifier;
    } catch (e) {
      log.error(`Could not calculate total pop modifier of type ${pop_type} for modifier ${raw_modifier}: ${e}`);
      console.error(e);
    }
  },

  getRelevantBuildingPops: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pops = Object.keys(config.pops);
    var relevant_pops = [];
    var usr = main.users[actual_id];

    //Iterate over .available_buildings
    for (var i = 0; i < usr.available_buildings.length; i++) {
      var local_building = lookup.all_buildings[usr.available_buildings[i]];

      if (local_building)
        if (local_building.manpower_cost) {
          var flattened_manpower_cost = flattenObject(local_building.manpower_cost);

          var all_manpower_keys = Object.keys(flattened_manpower_cost);

          //Iterate over all_manpower_keys
          for (var x = 0; x < all_manpower_keys.length; x++)
            if (!relevant_pops.includes(all_manpower_keys[x]))
              relevant_pops.push(all_manpower_keys[x]);
        }
    }

    //Return statement
    return relevant_pops;
  },

  //getRelevantPops() - Returns an array of all pop keys with more than 0 population in a player country
  getRelevantPops: function (arg0_user) {
    //Convert from parameters
    var user_id = arg0_user;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var all_pop_keys = Object.keys(config.pops);
    var relevant_pops = [];
    var usr = main.users[actual_id];

    //Iterate over all_pop_keys and check if usr.pops finds a match
    for (var i = 0; i < all_pop_keys.length; i++)
      if (config.pops[all_pop_keys[i]]) {
        var local_pop = config.pops[all_pop_keys[i]];
        var meets_conditions = true;

        //Global pop limit handling
        if (local_pop.disabled)
          meets_conditions = false;
        if (local_pop.industrial_pop)
          if (main.date.year < 1815)
            meets_conditions = false;

        if (meets_conditions)
          if (!relevant_pops.includes(all_pop_keys[i]))
            relevant_pops.push(all_pop_keys[i]);
      }

    //Return statement
    return relevant_pops;
  },

  mergePopScopes: function (arg0_pop_scope, arg1_pop_scope) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var ot_pop_scope = arg1_pop_scope;

    //Declare local instance variables
    var all_ot_pop_scope_keys = Object.keys(ot_pop_scope);
    var all_ot_pop_scope_tags = Object.keys(ot_pop_scope.tags);
    var all_pop_scope_keys = Object.keys(pop_scope);
    var all_pop_scope_tags = Object.keys(pop_scope.tags);
    var contributing_totals = {}; //{ pop_scope: 851903, ot_pop_scope: 481822 }. Tracks ALL tag totals for each pop_scope compared to ot_pop_scope
    var new_pop_scope = {
      tags: {}
    };

    //Fetch set intersection of all_ot_pop_scope_tags and all_pop_scope_tags and push it to new_pop_scope.tags
    for (var i = 0; i < all_pop_scope_tags.length; i++) {
      var local_ot_value = ot_pop_scope.tags[all_pop_scope_tags[i]]; //Intersect operation
      var local_value = pop_scope.tags[all_pop_scope_tags[i]];

      if (local_value && local_ot_value) {
        var local_min_clamp = Math.min(local_ot_value, local_value);
        var local_total = local_value + local_ot_value;
        new_pop_scope.tags[all_pop_scope_tags[i]] = local_min_clamp;

        modifyValue(contributing_totals, "pop_scope", (local_value/local_total)*local_min_clamp);
        modifyValue(contributing_totals, "ot_pop_scope", (local_ot_value/local_total)*local_min_clamp);
      }
    }

    //Based on contributing_totals; merge top level key-values via weighted average. If counterpart is undefined, assume 0
    var contributing_total = contributing_totals.pop_scope + contributing_totals.ot_pop_scope;
    contributing_totals.pop_percentage = contributing_totals.pop_scope/contributing_total;
    contributing_totals.ot_pop_percentage = contributing_totals.ot_pop_scope/contributing_total;

    for (var i = 0; i < all_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }
    for (var i = 0; i < all_ot_pop_scope_keys.length; i++) {
      var local_ot_value = returnSafeNumber(ot_pop_scope[all_pop_scope_keys[i]]);
      var local_value = returnSafeNumber(pop_scope[all_pop_scope_keys[i]]);

      new_pop_scope[all_pop_scope_keys[i]] = (local_value*contributing_totals.pop_percentage) + (local_ot_value*contributing_totals.ot_pop_percentage);
    }

    //Return statement
    return new_pop_scope;
  },

  /*
    modifyEducationLevel() - Changes the education level of selected pops in a given province. [REVISIT] - Add pop selector options in the future.
    options: {
      province_id: "4407", - Which province ID should be targeted by this function?

      min: 0, - Optional. 0 by default. For which brackets should the education level be raised? (Lower bound)
      max: 0, - Optional. 1 by default. For which brackets should the education level be raised?

      capacity: 50000, - Optional. Entire province population by default. How many people should be raised in terms of education at a time?
      value: 0.05 - How much should education levels within these brackets up to capacity be modified?
    }
  */
  modifyEducationLevel: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var province_obj = main.provinces[options.province_id];
    var total_eligible = 0;

    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);

        //Set defaults
        var max = Math.min(returnSafeNumber(options.max), 1);
        var min = Math.max(returnSafeNumber(options.min), 0);

        var capacity = (options.capacity) ? options.capacity : province_obj.pops.population;
        var value = returnSafeNumber(options.value);

        //Fetch education_profile_obj - lists current education profile; then standardise to percentages so that they can be moved up by their respective steps proportionally
        var education_profile_obj = {};
        var education_percentage_obj = {};

        //Iterate over all_pop_keys
        for (var i = 0; i < all_pop_keys.length; i++) {
          var local_value = province_obj.pops[all_pop_keys[i]];

          if (all_pop_keys[i].startsWith("el_")) {
            var local_key = all_pop_keys[i].replace("el_", "");
            var local_education_level = parseInt(local_key);

            if (local_education_level >= min && local_education_level <= max) {
              education_profile_obj[local_education_level] = local_value;
              total_eligible += local_value;
            }
          }
        }

        //Zero handler for total_eligible
        var uneducated_population = province_obj.pops.population - total_eligible;

        if (min <= 0)
          education_profile_obj[0] = uneducated_population;

        //Iterate over education_profile_obj to fetch education_percentage_obj
        var all_education_keys = Object.keys(education_profile_obj);

        for (var i = 0; i < all_education_keys.length; i++)
          education_percentage_obj[all_education_keys[i]] = education_profile_obj[all_education_keys[i]]/total_eligible;

        //Modify their actual education values now
        var new_keys = [];
        var rounding_overflow = 0;

        for (var i = 0; i < all_education_keys.length; i++) {
          var local_change = Math.ceil(capacity*education_percentage_obj[all_education_keys[i]]);
          var local_key = `el_${all_education_keys[i]}`;
          var new_value = parseInt(all_education_keys[i]) + Math.min(Math.ceil(value*100), 100);

          var new_key = `el_${new_value}`;

          if (local_change % 1 != 0) rounding_overflow++;

          modifyValue(province_obj.pops, local_key, local_change*-1);
          modifyValue(province_obj.pops, new_key, local_change);

          if (!new_keys.includes(new_key)) new_keys.push(new_key);

          //Clear useless keys
          if (province_obj.pops[local_key] <= 0)
            delete province_obj.pops[local_key];
          if (province_obj.pops[new_key] <= 0)
            delete province_obj.pops[new_key];
        }

        //Subtract rounding_overflow as much as possible
        for (var i = 0; i < new_keys.length; i++)
          if (rounding_overflow > 0) {
            var local_value = province_obj.pops[new_keys[i]];
            var value_removed = Math.min(local_value, rounding_overflow);

            modifyValue(province_obj.pops, new_keys[i], value_removed*-1);
            rounding_overflow -= value_removed;

            if (province_obj.pops[new_keys[i]] <= 0)
              delete province_obj.pops[new_keys[i]];
          }
      }
  },

  /*
    movePops() - Moves pops from one province to another.
    options: {
      do_not_layoff: true/false - Optional. False by default. Whether to layoff pops from their current jobs; if already laid off, switch to true.
    }
  */
  movePops: function (arg0_province_id, arg1_pop_scope, arg2_province_id, arg3_options) { //[WIP] - Make sure that original province still has enough tags to move out, lower bound it
    //Convert from parameters
    var from_province_id = arg0_province_id;
    var pop_scope = arg1_pop_scope;
    var to_province_id = arg2_province_id;
    var options = (arg3_options) ? arg3_options : {};

    //Declare local instance variables
    var from_building_map = getBuildingMap(from_province_id);
    var from_province = main.provinces[from_province_id];
    var to_province = main.provinces[to_province_id];

    //Initialise pop_scope
    if (!pop_scope.size) {
      pop_scope.province_id = from_province_id;
      pop_scope = selectPops(pop_scope);
    }

    var pop_scope_size = returnSafeNumber(pop_scope.size);

    //Move pops if pop_scope returned something
    if (pop_scope_size > 0) {
      //Handle tags
      var all_tags = Object.keys(pop_scope.tags);

      for (var i = 0; i < all_tags.length; i++) {
        var local_value = pop_scope.tags[all_tags[i]];

        //Wealth pool handler
        if (all_tags[i].startsWith("wealth-")) {
          if (!options.do_not_layoff) {
            var split_wealth_key = all_tags[i].split("-");

            var local_building_index = from_building_map[`${split_wealth_key[1]}-${split_wealth_key[2]}`];
            var local_building_obj = from_province.buildings[local_building_index];

            //Guard clause for subsistence handling
            if (local_building_obj)
              if (local_building_obj.id)
                layoffWorkers(local_building_obj, split_wealth_key[3], local_value);
          }
        } else {
          //Move non-wealth pop attributes
          modifyValue(from_province.pops, all_tags[i], local_value*-1, true);
          modifyValue(to_province.pops, all_tags[i], local_value);
        }
      }

      //Subtract from from_province.pops.population
      from_province.pops.population -= pop_scope.size;
      to_province.pops.population += pop_scope.size;
    }
  },

  multiplyPops: function (arg0_pop_scope, arg1_amount, arg2_is_birth) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var amount = arg1_amount;
    var is_birth = arg2_is_birth;

    //Declare local instance variables
    var all_pop_scope_tags = Object.keys(pop_scope.tags);
    var province_population = main.provinces[pop_scope.province_id].pops.population;

    if (pop_scope.size > 0) {
      pop_scope.size = Math.ceil(pop_scope.size*amount);

      if (!is_birth) {
        pop_scope.income = Math.ceil(pop_scope.income*amount);
        pop_scope.wealth = Math.ceil(pop_scope.wealth*amount);
      }

      //Iterate over all_pop_scope_tags
      for (var i = 0; i < all_pop_scope_tags.length; i++) {
        var is_mutable = false;
        var local_value = pop_scope.tags[all_pop_scope_tags[i]];

        //Check if pop tag is born with or not
        if (all_pop_scope_tags[i].startsWith("b_"))
          is_mutable = true;
        if (all_pop_scope_tags[i].startsWith("el_"))
          is_mutable = true;
        if (all_pop_scope_tags[i] == "population")
          is_mutable = true;
        if (all_pop_scope_tags[i].startsWith("used_"))
          is_mutable = true;
        if (all_pop_scope_tags[i].startsWith("wealth-"))
          is_mutable = true;

        if ((!is_mutable && is_birth) || !is_birth) {
          pop_scope.tags[all_pop_scope_tags[i]] = Math.ceil(local_value*amount);
        } else if (is_birth) {
          delete pop_scope.tags[all_pop_scope_tags[i]];
        }
      }

      //Birth handling
      if (is_birth)
        modifyValue(pop_scope.tags, `b_${main.date.year}`, pop_scope.size);
    }

    //Return statement
    return pop_scope;
  },

  parsePops: function () {
    //Declare local instance variables
    var all_pops = Object.keys(config.pops);

    //Process pop objects
    for (var i = 0; i < all_pops.length; i++) {
      var local_pop = config.pops[all_pops[i]];

      //Set icon values
      if (local_pop.icon) local_pop.icon = config.icons[local_pop.icon];
    }
  },

  /*
    processPop() - Processes pop type per province
    options: {
      sorted_wage_obj: {} - Optimisation parameter. The sorted wage object for the province.
    }
  */
  processPop: function (arg0_province_id, arg1_type, arg2_options) { //[WIP] - Add pop growth/decline/needs/migration later
    //Convert from parameters
    var province_id = arg0_province_id;
    var pop_type = arg1_type;
    var options = (arg2_options) ? arg2_options : {};

    //Declare local instance variables
    var building_map = getBuildingMap(province_id);
    var config_obj = config.pops[pop_type];
    var current_year = Math.floor(main.date.year);
    var has_demotes = false;
    var has_promotes = false;
    var pop_scope = selectPops({
      province_id: province_id,
      pop_types: [pop_type]
    });
    var province_obj = main.provinces[province_id];
    var user_id = province_obj.controller;
    var usr = main.users[user_id];

    var owner_id = province_obj.owner;
    var owner_usr = main.users[owner_id];

    var current_median = returnSafeNumber(province_obj[`${pop_type}_median_wage`]);

    var external_migration_table = lookup[`${province_obj.controller}-external_migration_attraction`];
    var internal_migration_table = lookup[`${province_obj.controller}-migration_attraction`];

    var all_external_provinces = Object.keys(external_migration_table);
    var all_internal_provinces = Object.keys(internal_migration_table);

    //Initialise variables
    {
      if (config_obj.demotes_to) has_demotes = true;
      if (config_obj.promotes_to) has_promotes = true;
    }

    //Pop Births and Deaths
    {
      //Birth handling
      {
        //Get province growth scalar
        var birth_scalar = returnSafeNumber(province_obj.births[pop_type], 1); //[REVISIT] - Fix this to .trackers.birth_modifiers
        var exceeds_pop_cap = false;
        var pop_percentage = pop_scope.size/province_obj.pops.population;
        var pop_growth_modifier = owner_usr.modifiers.pop_growth_modifier;

        var fertile_scalar = 1/(config.defines.economy.fertility_age_upper_bound - config.defines.economy.fertility_age_lower_bound);
        var pop_fertile_women = getProvinceFertileWomen(province_id)*pop_percentage;
        var pop_oefr = getPopOEFR(province_id, pop_type);
        var province_births = Math.ceil(pop_fertile_women*pop_oefr*fertile_scalar*returnSafeNumber(pop_growth_modifier, 1));
        var province_population = getProvincePopulation(province_id);

        var pop_turn_fertility = returnSafeNumber(
          province_births/unzero(returnSafeNumber(province_obj.pops[pop_type]))
        );

        if (province_obj.type == "rural") {
          if (province_obj.pop_cap)
            if (province_population >= province_obj.pop_cap)
              exceeds_pop_cap = true;
        } else {
          if (province_population >= returnSafeNumber(province_obj.housing))
            exceeds_pop_cap = true;
        }

        if (!usr.has_famine && !exceeds_pop_cap) {
          var birth_chance = selectorsToPercentage(parsePopLimit(config.births, {
            pop_scope: pop_scope,
            province_id: province_id
          })); //Standardise selectors

          //Iterate over birth_chance.selectors - [pop_scope, value]
          for (var i = 0; i < birth_chance.selectors.length; i++) {
            var initial_pop_scope = birth_chance.selectors[i][0];
            var local_value = birth_chance.selectors[i][1];

            if (initial_pop_scope.size > 0) {
              var local_scalar = ((province_births*local_value)/returnSafeNumber(initial_pop_scope.size));
              var population_change = Math.ceil(initial_pop_scope.size*local_scalar);

              var local_pop_scope = multiplyPops(initial_pop_scope, local_scalar, true);

              //Add to province_obj.trackers
              modifyValue(province_obj.trackers, `birth-${pop_type}`, population_change);

              //[REVISIT] - Statistical compounding on iterative variable subset theory ops is probably an inevitability unless you can work out the completeness of some NP-HARD maths theorem, Aust. Doing this for now - Vis
              var all_local_tags = Object.keys(local_pop_scope.tags);

              //Override tags - [WIP] THIS IS PROBABLY CAUSING ALL OTHER POPS TO ZERO OUT
              for (var x = 0; x < all_local_tags.length; x++)
                modifyValue(province_obj.pops, all_local_tags[x], local_pop_scope.tags[all_local_tags[x]]);
            }
          }
        }
      }

      //Death handling
      {
        //[REVISIT] - Fetch death pop scope arguments for accurate age distribution
        var life_expectancy = parsePopLimit(config.deaths.upper_bound_life_expectancy, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Kill people according to life_expectancy
        for (var i = 0; i < life_expectancy.selectors.length; i++) {
          var initial_pop_scope = life_expectancy.selectors[i][0];
          var local_value = life_expectancy.selectors[i][1];

          var local_life_expectancy = Math.floor(config.defines.economy.old_age_lower_upper_bound + local_value);
          var local_mortality = parabola(0, local_life_expectancy*2, config.defines.economy.life_expectancy_deaths);

          var all_mortality_keys = Object.keys(local_mortality);

          for (var x = 0; x < all_mortality_keys.length; x++) {
            var local_mortality_chance = local_mortality[all_mortality_keys[x]];
            var local_pop_scope = selectPops({
              pop_scope: initial_pop_scope,
              age: {
                min: parseInt(all_mortality_keys[x]),
                max: parseInt(all_mortality_keys[x]) + 1
              }
            });

            if (local_pop_scope.size > 0) {
              var remove_pop_scope = multiplyPops(local_pop_scope, local_mortality_chance);

              //Remove pops
              removePop(user_id, {
                amount: remove_pop_scope.size,
                pop_scope: remove_pop_scope
              });
              modifyValue(province_obj.trackers, `death-${pop_type}`, returnSafeNumber(remove_pop_scope.size));
            }
          }
        }

        //Kill people according to general mortality
        var general_mortality_chance = parsePopLimit(config.deaths.mortality, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Just kill people generally
        for (var i = 0; i < general_mortality_chance.selectors.length; i++) {
          var initial_pop_scope = general_mortality_chance.selectors[i][0];
          var local_value = general_mortality_chance.selectors[i][1];

          if (initial_pop_scope.size) {
            var remove_pop_scope = multiplyPops(initial_pop_scope, local_value);

            //Remove pops
            removePop(user_id, {
              amount: returnSafeNumber(remove_pop_scope.size),
              pop_scope: remove_pop_scope
            });
            modifyValue(province_obj.trackers, `death-${pop_type}`, returnSafeNumber(remove_pop_scope.size));
          }
        }
      }
    }

    //Pop Job Seeking and Employment
    {
      if (province_obj.buildings) {
        //Fetch remaining open positions
        var open_positions = 0;
        var total_job_seekers = 0;
        var unemployed_pops = getUnemployedPops(province_id, pop_type);

        var employed_pops = Math.max(province_obj.pops[pop_type] - unemployed_pops, 0);
        var employment_percentage = employed_pops/province_obj.pops[pop_type];

        for (var i = 0; i < province_obj.buildings.length; i++) {
          var local_building = province_obj.buildings[i];

          open_positions += returnSafeNumber(local_building[`${pop_type}_positions`]);
        }

        //Factor in current labour shortages to job seeking (whether a pop will resign from their current position)
        open_positions = Math.floor(returnSafeNumber(open_positions*employment_percentage));

        //Iterate over province_obj.buildings and if the wages are now below current_median, pop types should seek new jobs if higher positions exist
        if (open_positions > 0)
          for (var i = 0; i < province_obj.buildings.length; i++) {
            var local_building = province_obj.buildings[i];

            if (local_building.employment)
              if (local_building[`${pop_type}_wage`]) {
                var current_employees = returnSafeNumber(local_building.employment[pop_type]);
                var current_wage = local_building[`${pop_type}_wage`];

                if (current_wage < current_median) {
                  var new_job_seeker_percentage = (1 - (current_wage/unzero(current_median, 1)));

                  var new_job_seekers = current_employees*new_job_seeker_percentage;
                  new_job_seekers = Math.min(new_job_seekers, open_positions);

                  total_job_seekers += new_job_seekers;
                  layoffWorkers(local_building, pop_type, new_job_seekers);
                }
              }
          }

        //Process final employment both for those unemployed and those seeking a better job
        processEmployment(province_id, pop_type, {
          sorted_wage_obj: options.sorted_wage_obj,
          unemployed_pops: unemployed_pops
        });
      }
    }

    //Pop Migration
    /*{
      if (all_internal_provinces.length > 0) {
        //Get internal migration chance
        var internal_migration_chance = parsePopLimit(config.pop_migration.internal_emigration, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Apply internal migration to various pop scopes /2
        var internal_migration_scope = {};
        var internal_migration_scopes = [];

        for (var i = 0; i < internal_migration_chance.selectors.length; i++) {
          var local_value = internal_migration_chance.selectors[i];

          if (local_value[1] >= 0) {
            var local_chance = local_value[1]/2;
            var local_pop_scope = multiplyPops(local_value[0], local_chance);

            internal_migration_scopes.push(local_pop_scope);
          }
        }

        if (internal_migration_scopes.length > 0) {
          internal_migration_scope = internal_migration_scopes[0];

          if (internal_migration_scopes.length > 1)
            for (var i = 1; i < internal_migration_scopes.length; i++)
              internal_migration_scope = addPopScopes(internal_migration_scope, internal_migration_scopes[i]);

          //internal_migration_scopes is now the total amount of people that want to move out, transfer pops proportionally to internal provinces
          if (internal_migration_scope.size)
            for (var i = 0; i < all_internal_provinces.length; i++) {
              var local_value = internal_migration_table[all_internal_provinces[i]];
              var move_out_scope = multiplyPops(internal_migration_scope, local_value);
              var ot_province = main.provinces[all_internal_provinces[i]];

              if (local_value > 0) {
                modifyValue(province_obj.trackers, `emigration-${all_internal_provinces[i]}`, move_out_scope.size);
                modifyValue(ot_province.trackers, `immigration-${province_obj.id}`, move_out_scope.size);
                //movePops(province_obj.id, move_out_scope, all_internal_provinces[i]);
              }
            }
        }
      }

      if (all_external_provinces.length > 0) {
        //Get external migration chance
        var external_migration_chance = parsePopLimit(config.pop_migration.external_emigration, {
          pop_scope: pop_scope,
          province_id: province_id
        });

        //Apply external migration to various pop scopes /2 [WIP] - REVISIT LOGIC TO ACCOUNT FOR NATION SELECTION
        var external_migration_scope = {};
        var external_migration_scopes = [];

        for (var i = 0; i < external_migration_chance.selectors.length; i++) {
          var local_value = external_migration_chance.selectors[i];

          if (local_value[1] >= 0) {
            var local_chance = local_value[1]/2;
            var local_pop_scope = multiplyPops(local_value[0], local_chance);

            external_migration_scopes.push(local_pop_scope);
          }
        }

        if (external_migration_scopes.length > 0) {
          external_migration_scope = external_migration_scopes[0];

          if (external_migration_scopes.length > 1)
            for (var i = 1; i < external_migration_scopes.length; i++)
              external_migration_scope = addPopScopes(external_migration_scope, external_migration_scopes[i]);

          //external_migration_scopes is now the total amount of people that want to move out, transfer pops proportionally to external provinces
          if (external_migration_scope.size)
            for (var i = 0; i < all_external_provinces.length; i++) {
              var local_value = external_migration_table[all_external_provinces[i]];
              var move_out_scope = multiplyPops(external_migration_scope, external_migration_scopes[i]);
              var ot_province = main.provinces[all_external_provinces[i]];

              if (local_value > 0) {
                modifyValue(province_obj.trackers, `emigration-${all_external_provinces[i]}`, move_out_scope.size);
                modifyValue(province_obj.trackers, `immigration-${province_obj.id}`, move_out_scope.size);
                //movePops(province_obj.id, move_out_scope, all_external_provinces[i]);
              }
            }
        }
      }
    }*/

    //Pop Promotion/Demotion - [WIP] - Make it so that promotion/demotion can occur between classes if promotion/demotion is otherwise unspecified.
    /*if (pop_scope.size > 0) {
      //Pop demotion
      var pop_demotion_selectors = parsePopLimit(config.pop_mobility.demotion, {
        province_id: province_id,
        pop_type: pop_type,
        pop_scope: pop_scope
      });

      if (pop_demotion_selectors.boolean) {
        //pop_demotion_selectors.selectors - [pop_scope, value];
        for (var i = 0; i < pop_demotion_selectors.selectors.length; i++) {
          var local_pop_scope = pop_demotion_selectors.selectors[i][0];
          var local_value = pop_demotion_selectors.selectors[i][1];

          var all_local_tags = Object.keys(local_pop_scope.tags);

          if (has_demotes) {
            var all_demotes = Object.keys(config_obj.demotes_to);
            var demote_chances = {};

            for (var x = 0; x < all_demotes.length; x++)
              if (config.pops[all_demotes[x]]) { //Revamp to standardise percentage of config_obj.demotes_to to one another; calculate chances for all and standardise to 100%; apply to local_pop_scope
                var local_pop_demote_chance = parsePopLimit(config_obj.demotes_to[all_demotes[x]], {
                  province_id: province_id,
                  pop_type: pop_type,
                  pop_scope: pop_demotion_selectors.pop_scope
                });
                var weighted_total = 0;

                //Fetch weighted_total
                if (local_pop_demote_chance.boolean) {
                  for (var y = 0; y < local_pop_demote_chance.selectors.length; y++)
                    weighted_total += local_pop_demote_chance.selectors[y][0].size*
                      local_pop_demote_chance.selectors[y][1];

                  //Add weighted_total to demote_chances
                  modifyValue(demote_chances, all_demotes[x], weighted_total, true);
                }
              }

            //Standardise percentage for demote_chances; iterate over all of them and demote to respective pops
            demote_chances = standardisePercentage(demote_chances);

            var all_demote_chances = Object.keys(demote_chances);

            for (var x = 0; x < all_demote_chances.length; x++) {
              var local_percentage = demote_chances[all_demote_chances[x]];

              var local_demote_amount = Math.floor(returnSafeNumber(local_pop_scope[pop_type])*local_value*local_percentage);
              var local_used_demote = Math.floor(returnSafeNumber(local_pop_scope[`used_${pop_type}`])*local_value*local_percentage);

              //Layoff from wealth pools
              for (var y = 0; y < all_local_tags.length; y++)
                if (all_local_tags.startsWith("wealth-")) {
                  var local_layoff_amount = local_pop_scope.tags[all_local_tags[y]]*local_value*local_percentage;
                  var split_wealth_key = all_local_tags[y].split("-");

                  var local_building = building_map[`${split_wealth_key[1]}-${split_wealth_key[2]}`];

                  layoffWorkers(local_building, split_wealth_key[3], local_layoff_amount);
                }

              //Add to chosen profession
              modifyValue(province_obj.pops, pop_type, local_demote_amount*-1, true);
              modifyValue(province_obj.pops, pop_type, `used_${pop_type}`, local_used_demote*-1, true);
              modifyValue(province_obj.pops, all_demote_chances[x], local_demote_amount);

              //Set province tracker
              province_obj.trackers[`demote-${pop_type}-${all_demote_chances[x]}`] = local_demote_amount;
            }
          }
        }
      }

      //Pop promotion
      var pop_promotion_selectors = parsePopLimit(config.pop_mobility.promotion, {
        province_id: province_id,
        pop_type: pop_type,
        pop_scope: pop_scope
      });

      if (pop_promotion_selectors.boolean) {
        //pop_promotion_selectors.selectors - [pop_scope, value];
        for (var i = 0; i < pop_promotion_selectors.length; i++) {
          var local_pop_scope = pop_promotion_selectors.selectors[i][0];
          var local_value = pop_demotion_selectors.selectors[i][1];

          var all_local_tags = Object.keys(local_pop_scope.tags);

          if (has_promotes) {
            var all_promotes = Object.keys(config_obj.promotes_to);
            var promote_chances = {};

            for (var x = 0; x < all_promotes.length; x++)
              if (config.pops[all_promotes[x]]) {
                var local_pop_promote_chance = parsePopLimit(config_obj.promotes_to[all_promotes[x]], {
                  province_id: province_id,
                  pop_type: pop_type,
                  pop_scope: pop_promotion_selectors.pop_scope
                });
                var weighted_total = 0;

                //Fetch weighted_total
                if (local_pop_promote_chance.boolean)
                  for (var y = 0; y < local_pop_promote_chance.selectors.length; y++)
                    weighted_total += local_pop_promote_chance.selectors[y][0].size*local_pop_promote_chance.selectors[y][1];

                //Add weighted_total to promote_chances
                modifyValue(promote_chances, all_promotes[x], weighted_total, true);
              }

            //Standardise percentage for promote_chances; iterate over all of them and promote to respective pops
            promote_chances = standardisePercentage(promote_chances);

            var all_promote_chances = Object.keys(promote_chances);

            for (var x = 0; x < all_promote_chances.length; x++) {
              var local_percentage = promtoe_chances[all_promote_chances[x]];

              var local_promote_amount = Math.floor(returnSafeNumber(local_pop_scope[pop_type])*local_value*local_percentage);
              var local_used_promote = Math.floor(returnSafeNumber(local_pop_scope[`used_${pop_type}`])*local_value*local_percentage);

              //Layoff from wealth pools
              for (var y = 0; y < all_local_tags.length; y++)
                if (all_local_tags.startsWith("wealth-")) {
                  var local_layoff_amount = local_pop_scope.tags[all_local_tags[y]]*local_value*local_percentage;
                  var split_wealth_key = all_local_tags[y].split("-");

                  var local_building = building_map[`${split_wealth_key[1]}-${split_wealth_key[2]}`];

                  layoffWorkers(local_building, split_wealth_key[3], local_layoff_amount);
                }

              //Add to chosen profession
              modifyValue(province_obj.pops, pop_type, local_promote_amount*-1, true);
              modifyValue(province_obj.pops, pop_type, `used_${pop_type}`, local_used_promote*-1, true);
              modifyValue(province_obj.pops, all_promote_chances[x], local_promote_amount);

              //Set province tracker
              province_obj.trackers[`promote-${pop_type}-${all_promote_chances[x]}`] = local_promote_amount;
            }
          }
        }
      }
    }*/
  },

  //processPops() - Processes all pops in a given province
  processPops: function (arg0_province_id) {
    //Convert from parameters
    var province_id = arg0_province_id;

    //Declare local instance variables
    var all_pops = Object.keys(config.pops);
    var province_obj = (typeof province_id != "object") ? main.provinces[province_id] : province_id;
    var user_id = province_obj.controller;
    var usr = main.users[user_id];

    //Iterate over all pops and process them
    for (var i = 0; i < all_pops.length; i++) {
      //Initialise local tracker variables
      var local_sorted_wages = getBuildingWages(province_id, all_pops[i]);
      var median_wage = getMedianWage(province_id, {
        pop_type: all_pops[i],
        building_wage_obj: local_sorted_wages
      });

      //Set trackers
      province_obj.births = getProvinceBirthRate(user_id, province_id);
      province_obj[`${all_pops[i]}_median_wage`] = median_wage;

      //Sets .used_${all_pops[i]} to be accurate
      getProvinceEmployees(province_obj.id, all_pops[i]);

      //Pop processing
      processSubsistence(province_id, {
        category_prices: lookup.category_buy_prices
      });
      processPop(province_id, all_pops[i], {
        sorted_wage_obj: local_sorted_wages
      });

      //Kill off anyone over old-age upper bound
      {
        var over_upper_bound = selectPops({
          province_id: province_id,
          age: {
            min: config.defines.economy.old_age_hard_upper_bound,
            max: 1000
          },
          pop_types: [all_pops[i]]
        });
        removePop(user_id, {
          amount: over_upper_bound.size,
          pop_scope: over_upper_bound
        });

        //Iterate over all pops in over_upper_bound to track deaths
        modifyValue(province_obj.trackers, `death-${all_pops[i]}`, over_upper_bound.size);
      }
    }

    //Fix pops in province
    fixProvinces(user_id, province_obj.id);
  },

  /*
    removePop() - Removes pops from a province
    options: See selectPops(), additional options: {
      amount: 50000, - The amount of pops to remove.
      province_id: "5707", - The province ID to remove pops from.
      pop_scope: {} - Optional. The pop scope to pass to the argument
    }
  */
  removePop: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Initialise undeclared options
    if (!options.province_id)
      if (options.pop_scope)
        options.province_id = options.pop_scope.province_id;

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var killed = 0;
    var pop_scope = (!options.pop_scope) ? selectPops(options) : options.pop_scope;
    var province_obj = main.provinces[options.province_id];
    var usr = main.users[actual_id];

    //Subtract population
    if (province_obj) {
      var building_key_map = (options.building_key_map) ? options.building_key_map : getBuildingMap(options.province_id);

      if (pop_scope.size > 0) {
        //Temporary fix on age/culture tags
        standardiseAttributes(province_obj.id, "age");
        standardiseAttributes(province_obj.id, "culture");

        var all_tags = Object.keys(pop_scope.tags);
        var scalar = 1;

        if (options.amount < pop_scope.size)
          scalar = options.amount/pop_scope.size;

        //Remove all tags; lay off those in wealth pools
        for (var i = 0; i < all_tags.length; i++) {
          var local_value = Math.floor(pop_scope.tags[all_tags[i]]*scalar);

          if (all_tags[i].startsWith("wealth-")) {
            var local_wealth_pool = province_obj.pops[all_tags[i]];
            var split_wealth_key = all_tags[i].split("-");

            var building_id = `${split_wealth_key[1]}-${split_wealth_key[2]}`;
            var local_pop_type = split_wealth_key[3];

            if (!all_tags[i].includes("-subsistence-")) {
              var local_building = province_obj.buildings[building_key_map[building_id]];

              if (local_building)
                layoffWorkers(local_building, local_pop_type, local_value);
            } else {
              //Subsistence handler
              var subsistence_obj = province_obj.subsistence;

              if (subsistence_obj) {
                local_wealth_pool.income -= returnSafeNumber(local_wealth_pool.wealth*scalar);
                local_wealth_pool.wealth -= returnSafeNumber(local_wealth_pool.wealth*scalar);

                modifyValue(subsistence_obj.employment, local_pop_type, local_value*-1, true);

                if (!subsistence_obj.employment[local_pop_type])
                  delete province_obj.pops[all_tags[i]];
              }
            }
          } else {
            modifyValue(province_obj.pops, all_tags[i], local_value*-1, true);
          }
        }

        //Set killed
        killed = Math.floor(scalar*pop_scope.size);
      }

      if (options.pop_type)
        if (!province_obj.pops[options.pop_type])
          province_obj.pops[options.pop_type] = 0;
      if (province_obj.pops.population) {
        province_obj.pops.population -= returnSafeNumber(killed);
      } else {
        province_obj.pops.population = 0;
      }
    }

    //Return statement
    return killed;
  },

  /*
    removePops() - Kills a certain number of pops from a user based on the available options.
    options: {
      migration: true/false, - Whether the pops migrated or not instead of being killed. False by default
      options: {}, - Options for pop scope. Optional.
      provinces: ["6709", "6710"], - A list of provinces to target for removing pops. All of a user's provinces by default
      type: "soldiers", - Which type of pop to kill off
      amount: 10000 - How much of the pop to kill off
    }
  */
  removePops: function (arg0_user, arg1_options) {
    //Convert from parameters
    var user_id = arg0_user;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var actual_id = main.global.user_map[user_id];
    var decimation_obj = {};
    var economy_defines = config.defines.economy;
    options.type = (options.type) ?
      getList(options.type) : Object.keys(config.pops);
    var province_pop_scope_map = {};
    var remaining_population = returnSafeNumber(options.amount);
    var usr = main.users[actual_id];

    var decimation_array = splitNumber(1, options.type.length);
    var target_provinces = (options.provinces) ?
      getList(options.provinces) : shuffleArray(getProvinces(user_id, { return_keys: true }));

    //Initialise decimation_obj
    for (var i = 0; i < options.type.length; i++)
      decimation_obj[options.type[i]] = decimation_array[i];

    //Fetch total applicable pops over all target_provinces, options.amount/total_applicable_pops = % to remove from each province
    var local_options = {};
    var total_applicable_pops = 0;

    //Initialise local_options
    {
      local_options.pop_types = options.type;

      //Age handling
      {
        var has_age_argument = false;

        if (options.options)
          if (options.options.age)
            has_age_argument = true;

        if (!has_age_argument) {
          var is_only_military_pops = true;

          for (var i = 0; i < options.type.length; i++)
            if (!config.pops[options.type[i]].military_pop)
              is_only_military_pops = false;

          if (is_only_military_pops)
            local_options.age = {
              min: economy_defines.soldier_age_lower_bound,
              max: economy_defines.soldier_age_upper_bound,
              mean: Math.floor((economy_defines.soldier_age_lower_bound + economy_defines.soldier_age_upper_bound)/2)
            };
        }
      }

      if (options.options)
        local_options = mergeObjects(local_options, options.options);
    }

    //Iterate over all target_provinces using selectPops() scope
    for (var i = 0; i < target_provinces.length; i++) {
      //Deep copy local_options to new_options and set province_id
      var new_options = JSON.parse(JSON.stringify(local_options));
      new_options.province_id = target_provinces[i];

      var local_pop_scope = selectPops(new_options);
      total_applicable_pops += local_pop_scope.size;
      province_pop_scope_map[new_options.province_id] = local_pop_scope;
    }

    //Remove pops from target_provinces based on scalar of options.amount/total_applicable_pops
    var kill_scalar = options.amount/total_applicable_pops;
    var soldiers_killed = 0;
    var total_removed = 0;

    for (var i = 0; i < target_provinces.length; i++) {
      var local_pop_scope = province_pop_scope_map[target_provinces[i]];

      total_removed += removePop(user_id, {
        amount: Math.ceil(kill_scalar*local_pop_scope.size),
        province_id: target_provinces[i],
        pop_scope: local_pop_scope
      });

      for (var x = 0; x < options.type.length; x++) {
        var config_obj = config.pops[options.type[x]];

        if (config_obj.military_pop)
          soldiers_killed += returnSafeNumber(local_pop_scope[options.type[x]]);
      }
    }

    //Add to civilian/military casualties tracker
    if (!options.migration)
      if (!usr) {
        usr.recent_military_casualties[usr.recent_military_casualties.length - 1] += soldiers_killed;
        usr.recent_civilian_casualties[usr.recent_civilian_casualties.length - 1] += Math.max(total_removed - soldiers_killed, 0);
      }

    //Return statement
    return total_removed;
  },

  /*
    selectPops() - Merges pops based on a pop's characteristics and given frequency distributions according to proportionality.
    options: {
      amount: 50000, - The number of pops to select
      province_id: "4707", - The province ID to merge pops from. Optional with pop_scope as an additional option
      pop_scope: {}, - The pop scope to provide to get a subset of

      age: { - Optional. Undefined by default
        min: 20,
        max: 35,
        mean: 25 - Optional. Midpoint by default
      },
      age: 47, - Optional. Number argument. Overrides top argument.
      building_ids: [], - A given list of building ID's to select employed pops from
      culture: [], - A list of culture IDs that should be scoped to
      education_level: { - Optional. Undefined by default
        min: 0,
        max: 1,
        mean: 0.50 - Optional. Midpoint by default
      },
      education_level_less_than: 0.50, - Optional. Undefined by default.
      empty: true/false, - Optional. Whether to return an empty pop scope. False by default
      has_accepted_culture: true/false, - Optional. Restricts pops to accepted cultures only
      has_<goods_category>: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      has_<goods_category>_less_than: 0.80, - Optional. Numeric percentage. Undefined by default
      has_<goods_category>_variety: true/false/0.50, - Optional. Either boolean or numeric value. Undefined by default
      has_<goods_category>_variety_less_than: 0.90, - Optional. Undefined by default
      homeless: true/false, - Optional. Whether the pop is currently homeless. Undefined by default
      income: 500, - Optional. What income levels should be targeted in scope. Undefined by default
      income_less_than: 250, - Optional. What income levels should be targeted in scope. Undefined by default
      is_employed: true/false, - Optional. Whether the pop should be employed or not. Undefined by default
      pop_types: [], - A given list of pop types to return a single pop from. Returns all pops by default
      wealth: 40000, - Optional. What their wealth should be above or equal to
      wealth_less_than: 20000 - Optional. What their wealth should be below or equal to
    }

    Returns: {
      size: 4407, - The size of the pop that meets the aforementioned categories
      income: 0, - Their relative income last turn. All metrics given in weighted averages
      wealth: 0, - Their current wealth

      staple_goods-fulfilment: 0.86, - Category specific fulfilment and variety
      staple_goods-variety: 0.60,
      ..

      fulfilment: 0.67, - General fulfilment and variety
      variety: 0.15,
      ..

      //Key-value pairings that would be selected from this merge pop scope
      tags: {
        labourers: 4407,
        engineers: 2202,
        used_engineers: 1105,
        ..

        wealth-<building_id>-<pop_type>: 2505
      }
    }
  */
  selectPops: function (arg0_options) {
    //Convert from parameters
    var options = (arg0_options) ? arg0_options : {};

    //Declare local instance variables
    var current_scope = {
      size: 0,
      income: 0,
      wealth: 0,

      tags: {}
    };
    var province_id = (options.pop_scope) ? options.pop_scope.province_id : options.province_id;
    var province_obj = main.provinces[province_id];

    //Initialise options
    if (!options.pop_types) options.pop_types = Object.keys(config.pops);

    //Declare local instance variables
    var all_options = Object.keys(options);

    //Declare pop categories
    var age_tags = {};
    var culture_tags = {};
    var education_level_tags = {};
    var employed_tags = {}; //Differential boolean with is_unemployed
    var homeless_amount = 0; //Boolean with housed_amount
    var housed_amount = 0; //Boolean with homeless_amount
    var is_unemployed = 0; //Differential boolean with employed_tags
    var pop_type_tags = {};
    var wealth_pool_tags = {};

    var has_wealth_hard_specified = false;

    //Trackers for internal purposes
    var total_employed = 0;
    var total_fulfilment = {};
    var total_general_fulfilment = 0;
    var total_general_variety = 0;
    var total_income = 0;
    var total_variety = {};
    var total_wealth = 0;
    var total_wealth_pools = 0;

    //Check if province even has pops
    if (province_obj.pops) {
      var all_pop_keys = Object.keys(province_obj.pops);

      //Parse superobjects first, such as wealth pools
      for (var i = 0; i < all_pop_keys.length; i++) {
        var local_value = province_obj.pops[all_pop_keys[i]];

        if (typeof local_value == "object")
          if (all_pop_keys[i].startsWith("wealth-")) {
            var all_conditions_met = true;
            var all_wealth_keys = Object.keys(local_value);
            var split_wealth_key = all_pop_keys[i].split("-");

            var building_id = `${split_wealth_key[1]}-${split_wealth_key[2]}`;
            var local_pop_type = split_wealth_key[3];

            //Building ID handler
            if (options.building_ids)
              if (!options.building_ids.includes(building_id))
                all_conditions_met = false;

            //Employed handler
            if (options.is_employed == false)
              all_conditions_met = false;

            //Goods category fulfilment handler; Goods category variety handler
            for (var x = 0; x < all_options.length; x++) {
              //has_<goods_category>
              if (all_options[x].startsWith("has_")) {
                var local_goods_category = all_options[x].replace("has_", "");
                has_wealth_hard_specified = true;

                if (returnSafeNumber(local_value[`${local_goods_category}-fulfilment`]) < options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_less_than
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_less_than")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_less_than", "");
                has_wealth_hard_specified = true;

                if (returnSafeNumber(local_value[`${local_goods_category}-fulfilment`]) >= options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_variety
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_variety")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_variety", "");
                has_wealth_hard_specified = true;

                if (returnSafeNumber(local_value[`${local_goods_category}-variety`]) < options[all_options[x]])
                  all_conditions_met = false;
              }

              //has_<goods_category>_variety_less_than
              if (all_options[x].startsWith("has_") && all_options[x].endsWith("_variety_less_than")) {
                var local_goods_category = all_options[x].replace("has_", "").replace("_variety_less_than", "");
                has_wealth_hard_specified = true;

                if (returnSafeNumber(local_value[`${local_goods_category}-variety`]) >= options[all_options[x]])
                  all_conditions_met = false;
              }
            }

            //Income handler
            var actual_income = local_value.income/local_value.size;

            if (options.income)
              if (actual_income < options.income) {
                all_conditions_met = false;
                has_wealth_hard_specified = true;
              }

            if (options.income_less_than)
              if (actual_income >= options.income_less_than) {
                all_conditions_met = false;
                has_wealth_hard_specified = true;
              }

            //Pop type handler
            if (!options.pop_types.includes(local_pop_type))
              all_conditions_met = false;

            //Wealth handler
            var actual_wealth = local_value.wealth/local_value.size;

            if (options.wealth)
              if (actual_wealth < options.wealth) {
                all_conditions_met = false;
                has_wealth_hard_specified = true;
              }

            if (options.wealth_less_than)
              if (actual_wealth >= options.wealth_less_than) {
                all_conditions_met = false;
                has_wealth_hard_specified = true;
              }

            //Append to wealth_pool_tags if all_conditions_met
            if (all_conditions_met) {
              modifyValue(employed_tags, `used_${local_pop_type}`, local_value.size);
              modifyValue(wealth_pool_tags, all_pop_keys[i], local_value.size);

              //total_fulfilment, total_variety handler
              for (var x = 0; x < all_wealth_keys.length; x++) {
                var local_pool_value = local_value[all_wealth_keys[x]];

                if (all_wealth_keys[x].endsWith("-fulfilment")) {
                  modifyValue(total_fulfilment, all_wealth_keys[x], local_pool_value);
                } else if (all_wealth_keys[x].endsWith("-variety")) {
                  modifyValue(total_variety, all_wealth_keys[x], local_pool_value);
                }
              }

              total_general_fulfilment += returnSafeNumber(local_value.fulfilment);
              total_general_variety += returnSafeNumber(local_value.variety);

              //.income, .wealth handler
              total_income += actual_income;
              total_wealth += actual_wealth;
              total_wealth_pools++;
            }
          }
      }

      //Parse Pearson objects next
      {
        //Age handler
        if (typeof options.age == "object") {
          var max = returnSafeNumber(options.age.max, config.defines.economy.old_age_hard_upper_bound);
          var min = returnSafeNumber(options.age.min, 0);

          if (!options.age.mean) { //Block select
            for (var i = 0; i < all_pop_keys.length; i++) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              if (all_pop_keys[i].startsWith("b_")) {
                var birth_year = parseInt(all_pop_keys[i].replace("b_", ""));
                var current_age = Math.floor(main.date.year - birth_year);

                if (current_age >= min && current_age <= max)
                  modifyValue(age_tags, all_pop_keys[i], local_value);
              }
            }
          } else { //Skewed pearson object
            var mean = returnSafeNumber(options.age.mean);

            var age_distribution = pearsonVIIDistribution(max, mean, min, max);
            var all_age_distribution_keys = Object.keys(age_distribution);

            for (var i = 0; i < all_age_distribution_keys.length; i++) {
              var local_birth_year = Math.floor(main.date.year - parseInt(all_age_distribution_keys[i]));
              var local_percentage = age_distribution[all_age_distribution_keys[i]];
              var local_value = Math.floor(returnSafeNumber(province_obj.pops[`b_${local_birth_year}`])*local_percentage);

              modifyValue(age_tags, `b_${local_birth_year}`, local_value);
            }
          }
        } else {
          //Age number handler - Block select
          var max = config.defines.economy.old_age_hard_upper_bound;
          var min = returnSafeNumber(options.age, 0);

          for (var i = 0; i < all_pop_keys.length; i++) {
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (all_pop_keys[i].startsWith("b_")) {
              var birth_year = parseInt(all_pop_keys[i].replace("b_", ""));
              var current_age = Math.floor(main.date.year - birth_year);

              if (current_age >= min && current_age <= max)
                modifyValue(age_tags, all_pop_keys[i], local_value);
            }
          }
        }

        //Education level handler
        if (typeof options.education_level == "object") {
          var max = returnSafeNumber(options.education_level.max, 1);
          var min = returnSafeNumber(options.education_level.min, 0);

          if (!options.education_level.mean) {
            for (var i = 0; i < all_pop_keys.length; i++) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              if (all_pop_keys[i].startsWith("el_")) {
                var education_level = parseInt(local_value.replace("el_", ""));

                if (education_level >= min*100 && education_level <= max*100)
                  modifyValue(education_level_tags, `el_${education_level}`, local_value);
              }
            }
          } else {
            var mean = returnSafeNumber(options.education_level.mean);

            var education_distribution = pearsonVIIDistribution(100, mean, min, max, {
              key_name: "el"
            });
            var all_education_distribution_keys = Object.keys(education_distribution);

            for (var i = 0; i < all_education_distribution_keys.length; i++) {
              var local_amount = education_distribution[all_education_distribution_keys[i]];
              var local_education_amount = returnSafeNumber(province_obj.pops[all_education_distribution_keys[i]]);
              var local_value = local_education_amount*local_amount;

              modifyValue(education_level_tags, all_education_distribution_keys[i], local_value);
            }
          }
        } else if (options.education_level_less_than) {
          for (var i = 0; i < all_pop_keys.length; i++) {
            var local_value = province_obj.pops[all_pop_keys[i]];

            if (all_pop_keys[i].startsWith("el_")) {
              var education_level = parseInt(local_value.replace("el_", ""));

              if (education_level < options.education_level_less_than*100)
                modifyValue(education_level_tags, `el_${education_level}`, local_value);
            }
          }
        }
      }

      //Parse simple tag pop categories next
      for (var i = 0; i < all_pop_keys.length; i++) {
        var local_value = province_obj.pops[all_pop_keys[i]];

        if (typeof local_value != "object") {
          //Culture handler
          if (options.culture)
            if (all_pop_keys[i].startsWith("culture-")) {
              var culture_id = all_pop_keys[i].replace("culture-", "");

              if (options.culture.includes(culture_id))
                modifyValue(culture_tags, all_pop_keys[i], local_value);
            }

          //Pop type handler
          if (config.pops[all_pop_keys[i]])
            if (options.pop_types.includes(all_pop_keys[i]))
              modifyValue(pop_type_tags, all_pop_keys[i], local_value);
          if (all_pop_keys[i] == `used_${all_pop_keys[i]}`) {
            var local_pop_key = all_pop_keys[i].replace("used_", "");

            if (config.pops[local_pop_key])
              modifyValue(pop_type_tags, local_pop_key, local_value);
          }
        }
      }

      //Non-iterative boolean pop categories
      {
        //Homeless handler
        homeless_amount = province_obj.pops.population - returnSafeNumber(province_obj.housing);

        //Housed handler
        housed_amount = province_obj.pops.population - homeless_amount;

        //Unemployed handler
        {
          if (options.is_employed != undefined) {
            for (var i = 0; i < options.pop_types.length; i++)
              total_employed += returnSafeNumber(province_obj.pops[`used_${options.pop_types[i]}`]);

            is_unemployed = province_obj.pops.population - total_employed;
          }
        }
      }

      //Fetch the total % of province population that is an intersection of the pop category tags defined above by multiplying category_sum/province_population together. Only those specified in options should be applicable. See Belgian Workers problem for more information.

      //Note that wealth superobjects are scaled to total_employed and not province_obj.pops.population

      var category_scalars = {};
      var hard_specified_categories = [];
      var hard_specified_tags = {}; //Hard specified tags are just anything that has Object.keys().length > 0
      var pop_scalar = 1; //Multiplied iteratively by each consecutive category; then all other pop tags in the province not hard specified are multiplied by this to fetch final .tags result
      var relative_scalars = {};

      var category_tags = {
        age: age_tags,
        culture: culture_tags,
        education: education_level_tags,
        is_employed: {},
        homeless: {},
        pop_types: pop_type_tags,
        wealth: wealth_pool_tags
      };

      //Reduce category_tags to key list
      var all_category_tags = Object.keys(category_tags);

      for (var i = 0; i < all_category_tags.length; i++) {
        var local_value = category_tags[all_category_tags[i]];

        category_tags[all_category_tags[i]] = Object.keys(local_value);
      }

      {
        //Age handler
        if (options.age) {
          hard_specified_tags = mergeObjects(age_tags, hard_specified_tags);
          var local_scalar = getObjectSum(age_tags)/province_obj.pops.population;

          category_scalars.age = local_scalar;
          pop_scalar = pop_scalar*returnSafeNumber(local_scalar);

          hard_specified_categories.push("age");
        }

        //Culture handler
        if (options.culture) {
          hard_specified_tags = mergeObjects(culture_tags, hard_specified_tags);
          var local_scalar = getObjectSum(culture_tags)/province_obj.pops.population;

          category_scalars.culture = local_scalar;
          pop_scalar = pop_scalar*returnSafeNumber(local_scalar);

          hard_specified_categories.push("culture");
        }

        //Education level handler
        if (options.education_level || options.education_level_less_than) {
          hard_specified_tags = mergeObjects(education_level_tags, hard_specified_tags);
          var local_scalar = getObjectSum(education_level_tags)/province_obj.pops.population;

          category_scalars.education = local_scalar;
          pop_scalar = pop_scalar*returnSafeNumber(local_scalar);

          hard_specified_categories.push("education");
        }

        //Employed handler; Unemployed handler
        if (options.is_employed != undefined) {
          if (options.is_employed == true) {
            var local_scalar = is_unemployed/province_obj.pops.population;

            category_scalars.is_employed = local_scalar;
            pop_scalar = pop_scalar*(is_unemployed/province_obj.pops.population);
          } else if (options.is_employed == false) {
            var local_scalar = total_employed/province_obj.pops.population;

            category_scalars.is_employed = local_scalar;
            pop_scalar = pop_scalar*returnSafeNumber(local_scalar);
          }

          hard_specified_categories.push("is_employed");
        }

        //Homeless handler; Housed handler - Boolean
        if (options.homeless != undefined) {
          if (options.homeless == true) {
            var local_scalar = homeless_amount/province_obj.pops.population;

            category_scalars.homeless = local_scalar;
            pop_scalar = pop_scalar*returnSafeNumber(local_scalar);
          } else if (options.homeless == false) {
            var local_scalar = housed_amount/province_obj.pops.population;

            category_scalars.homeless = local_scalar;
            pop_scalar = pop_scalar*returnSafeNumber(local_scalar);
          }

          hard_specified_categories.push("homeless");
        }

        //Pop type handler
        if (options.pop_types) {
          hard_specified_tags = mergeObjects(pop_type_tags, hard_specified_tags);
          var local_scalar = getObjectSum(pop_type_tags)/province_obj.pops.population;

          category_scalars.pop_types = local_scalar;
          pop_scalar = pop_scalar*returnSafeNumber(local_scalar);

          hard_specified_categories.push("pop_types");
        }

        //Wealth pool handler - Superobject; scaled to total_employed - [REVISIT]
        if (Object.keys(wealth_pool_tags).length > 0 || has_wealth_hard_specified) {
          hard_specified_tags = mergeObjects(wealth_pool_tags, hard_specified_tags);
          var local_scalar = getObjectSum(wealth_pool_tags)/province_obj.pops.population;

          category_scalars.wealth = local_scalar;
          pop_scalar = pop_scalar*returnSafeNumber(local_scalar);
          hard_specified_categories.push("wealth");
        }

        //Calculate relative_scalars from category_scalars;
        var all_category_scalars = Object.keys(category_scalars);

        for (var i = 0; i < all_category_scalars.length; i++) {
          var key_to_exclude = all_category_scalars[i];
          var relative_scalar = 1;

          if (all_category_scalars.length > 1)
            for (var x = 0; x < all_category_scalars.length; x++)
              if (all_category_scalars[x] != key_to_exclude) {
                var local_value = category_scalars[all_category_scalars[x]];
                relative_scalar = Math.min(relative_scalar*local_value, 1);
              }

          //Set relative_scalar
          relative_scalars[all_category_scalars[i]] = relative_scalar;
        }

        //Scale hard_specified_tags by relative_scalar[hard_specified_tags[i]] (check against category_tags to determine category of tag)
        var all_hard_specified_tags = Object.keys(hard_specified_tags);

        for (var i = 0; i < all_hard_specified_tags.length; i++) {
          var local_selector_category;
          var local_value = hard_specified_tags[all_hard_specified_tags[i]];

          for (var x = 0; x < all_category_tags.length; x++)
            if (category_tags[all_category_tags[x]].includes(all_hard_specified_tags[i]))
              local_selector_category = all_category_tags[x];

          //Set hard scale (this is the scalar compared to the scalars of all the other relevant categories being scoped for)
          if (local_selector_category)
            hard_specified_tags[all_hard_specified_tags[i]] = local_value*relative_scalars[local_selector_category];
        }

        //Merge hard_specified_tags with current_scope.tags
        current_scope.tags = mergeObjects(hard_specified_tags, current_scope.tags);
      }
    }

    //Multiply remaining unaccounted province tags by pop_scalar and merge to current_scope.tags (floored)
    var soft_specified_tags = {};

    //Initialise soft_specified_tags
    {
      for (var i = 0; i < all_pop_keys.length; i++)
        if (hard_specified_tags[all_pop_keys[i]] == undefined) {
          var is_hard_specified = false;
          var local_value = province_obj.pops[all_pop_keys[i]];

          //Number/object handler
          if (typeof local_value == "number") {
            //Make sure value is not in hard_specified_categories; inverse qualification theorem
            {
              //Age handler
              if (hard_specified_categories.includes("age"))
                if (all_pop_keys[i].startsWith("b_"))
                  is_hard_specified = true;

              //Culture handler
              if (hard_specified_categories.includes("culture"))
                if (all_pop_keys[i].startsWith("culture-"))
                  is_hard_specified = true;

              //Education level handler
              if (hard_specified_categories.includes("education"))
                if (all_pop_keys[i].startsWith("el_"))
                  is_hard_specified = true;

              //Employed handler; Unemployed handler
              if (hard_specified_categories.includes("is_employed"))
                if (all_pop_keys[i].startsWith("used_"))
                  is_hard_specified = true; //This is already handled in wealth_pool_tags

              //Pop type handler
              if (hard_specified_categories.includes("pop_types")) {
                if (config.pops[all_pop_keys[i]])
                  is_hard_specified = true;
                if (all_pop_keys[i].startsWith("used_")) {
                  var local_pop_key = all_pop_keys[i].replace("used_", "");

                  if (config.pops[local_pop_key])
                    is_hard_specified = true;
                }
              }
            }

            if (!is_hard_specified)
              modifyValue(soft_specified_tags, all_pop_keys[i], Math.floor(local_value*pop_scalar));
          } else if (typeof local_value == "object") {
            //Only valid if no wealth_pool_tags are found
            if (Object.keys(wealth_pool_tags).length == 0)
              //Check if local_value is wealth pool
              if (all_pop_keys[i].startsWith("wealth-")) {
                var split_key = all_pop_keys[i].split("-");

                //Push to soft_specified_tags
                modifyValue(soft_specified_tags, all_pop_keys[i], Math.floor(local_value.size*pop_scalar));
              }
          }
        }
    }

    //Merge soft_specified_tags with current_scope.tags
    current_scope.tags = mergeObjects(soft_specified_tags, current_scope.tags);

    //Set .income, .wealth
    current_scope.income = returnSafeNumber(Math.ceil(total_income/total_wealth_pools));
    current_scope.wealth = returnSafeNumber(Math.ceil(total_wealth/total_wealth_pools));
    current_scope.size = returnSafeNumber(Math.ceil(province_obj.pops.population*pop_scalar));

    //Set fulfilment, variety tags
    var all_fulfilment_keys = Object.keys(total_fulfilment);
    var all_variety_keys = Object.keys(total_variety);

    for (var i = 0; i < all_fulfilment_keys.length; i++) {
      var local_value = total_fulfilment[all_fulfilment_keys[i]];

      total_fulfilment[all_fulfilment_keys[i]] = local_value/total_wealth_pools;
    }
    for (var i = 0; i < all_variety_keys.length; i++) {
      var local_value = total_variety[all_variety_keys[i]];

      total_variety[all_variety_keys[i]] = local_value/total_wealth_pools;
    }

    current_scope = mergeObjects(current_scope, total_fulfilment);
    current_scope = mergeObjects(current_scope, total_variety);

    current_scope.fulfilment = returnSafeNumber(total_general_fulfilment/total_wealth_pools);
    current_scope.variety = returnSafeNumber(total_general_variety/total_wealth_pools);

    //POST-PROCESSING - current_scope.tags
    {
      var all_current_tags = Object.keys(current_scope.tags);

      for (var i = 0; i < all_current_tags.length; i++) {
        var local_value = current_scope.tags[all_current_tags[i]];

        current_scope.tags[all_current_tags[i]] = Math.floor(local_value);
        if (local_value > current_scope.size)
          current_scope.tags[all_current_tags[i]] = current_scope.size;
      }

      //If amount is specified, scale to amount
      if (options.amount) {
        var amount_scalar = options.amount/current_scope.size;

        for (var i = 0; i < all_current_tags.length; i++) {
          var local_value = current_scope.tags[all_current_tags[i]];

          current_scope.tags[all_current_tags[i]] = Math.floor(local_value*amount_scalar);
        }

        //Adjust main characteristics
        if (current_scope.size > options.amount)
          current_scope.size = options.amount;
        current_scope.income = current_scope.income*amount_scalar;
        current_scope.wealth = current_scope.wealth*amount_scalar;
      }

      //Iterate over all_current_tags and delete 0's
      for (var i = 0; i < all_current_tags.length; i++) {
        var local_value = current_scope.tags[all_current_tags[i]];

        if (returnSafeNumber(local_value) == 0)
          delete current_scope.tags[all_current_tags[i]];
      }
    }

    //Tracker tags
    current_scope.province_id = province_id;

    //Return statement
    return current_scope;
  },

  /*
    selectorsToPercentage() - Standardises a set of .selectors to a percentage
    options: {
      do_not_standardise: true/false - Optional. Whether to not standardise percentage. False by default
    }
  */
  selectorsToPercentage: function (arg0_pop_scope, arg1_options) {
    //Convert from parameters
    var pop_scope = arg0_pop_scope;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var new_pop_scope = JSON.parse(JSON.stringify(pop_scope));
    var selector_percentages = {};

    //Check if pop_scope has selectors
    if (new_pop_scope.selectors)
      for (var i = 0; i < new_pop_scope.selectors.length; i++) {
        var local_value = new_pop_scope.selectors[i];

        local_value[1] = 1 + local_value[1];

        if (local_value[1] < 0)
          local_value[1] = 0;

        //Set local_value
        selector_percentages[i] = local_value[1];
      }

    //Standardise selectors if do_not_standardise is false
    if (!options.do_not_standardise) {
      selector_percentages = standardisePercentage(selector_percentages);

      //Iterate over selector_percentages
      var all_selector_percentages = Object.keys(selector_percentages);

      for (var i = 0; i < all_selector_percentages.length; i++)
        new_pop_scope.selectors[all_selector_percentages[i]][1] = selector_percentages[all_selector_percentages[i]];
    }

    //Return statement
    return new_pop_scope;
  },

  /*
    sortWealthPools() - Sorts wealth pool objects in province,
    options: {
      mode: "income"/"pop_type"/"size"/"wealth", - Optional. "size" by default
      return_object: true/false - Whether to return wealth pools as a single object. Returns keys by default
    }
  */
  sortWealthPools: function (arg0_province_id, arg1_options) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var options = (arg1_options) ? arg1_options : {};

    //Declare local instance variables
    var mode = (options.mode) ? options.mode : "size";
    var province_obj = (typeof province_id != "object") ? main.provinces[province_id] : province_id;
    var return_obj = {};
    var subsistence_obj = {};

    //Iterate over province_obj.pops for wealth pools
    if (province_obj.pops) {
      var all_pops = Object.keys(config.pops);
      var all_pop_keys = Object.keys(province_obj.pops);
      var regular_wealth_pools = [];

      //Subsistence pools go up top
      for (var i = 0; i < all_pop_keys.length; i++)
        if (all_pop_keys[i].startsWith("wealth-")) {
          var local_value = province_obj.pops[all_pop_keys[i]];

          if (all_pop_keys[i].includes("subsistence")) {
            local_value.key = all_pop_keys[i];
            subsistence_obj[all_pop_keys[i]] = local_value;
          } else {
            //Non-subsistence handling
            var split_key = all_pop_keys[i].split("-");
            var pop_type = split_key[3];

            local_value.key = all_pop_keys[i];
            local_value.pop_type = pop_type;

            regular_wealth_pools.push(local_value);
          }
        }

      //Sort wealth pools by mode in descending order
      if (mode == "income") {
        regular_wealth_pools.sort((a, b) => b.income - a.income);
      } else if (mode == "size") {
        regular_wealth_pools.sort((a, b) => b.size - a.size);
      } else if (mode == "pop_type") {
        regular_wealth_pools.sort((a, b) => b.pop_type - a.pop_type);
      } else if (mode == "wealth") {
        regular_wealth_pools.sort((a, b) => b.wealth - a.wealth);
      }

      //Append regular_wealth_pools/new_wealth_pools to subsistence_obj as a sorted_wealth_pools_obj
      var sorted_wealth_pools_obj = {};

      for (var i = 0; i < regular_wealth_pools.length; i++) {
        var local_value = regular_wealth_pools[i];

        sorted_wealth_pools_obj[local_value.key] = local_value;
        var local_wealth_pool = sorted_wealth_pools_obj[local_value.key];

        delete local_wealth_pool.key;
        delete local_wealth_pool.pop_type;
      }

      return_obj = mergeObjects(subsistence_obj, sorted_wealth_pools_obj);

      //Return statements
      return (!options.return_object) ? Object.keys(return_obj) : return_obj;
    }
  },

  /*
    standardiseAttributes() - Standardises a set of attributes to 100% of the population.
    mode: "age"/"culture"
  */
  standardiseAttributes: function (arg0_province_id, arg1_mode) {
    //Convert from parameters
    var province_id = arg0_province_id;
    var mode = arg1_mode.toString().trim();

    //Declare local instance variables
    var province_obj = (typeof province_id != "object") ? main.provinces[province_id] : province_id;
    var tag_obj = {};

    //Standardise to mode
    if (province_obj)
      if (province_obj.pops) {
        var all_pop_keys = Object.keys(province_obj.pops);
        var province_population = province_obj.pops.population;

        if (mode == "age") {
          for (var i = 0; i < all_pop_keys.length; i++)
            if (all_pop_keys[i].startsWith("b_")) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              tag_obj[all_pop_keys[i]] = local_value;
            }
          for (var i = 0; i < all_pop_keys.length; i++)
            if (all_pop_keys[i].startsWith("b_"))
              delete province_obj.pops[all_pop_keys[i]];

          tag_obj = standardisePercentage(tag_obj, province_population, true);
        } if (mode == "culture") {
          for (var i = 0; i < all_pop_keys.length; i++)
            if (all_pop_keys[i].startsWith("culture-")) {
              var local_value = province_obj.pops[all_pop_keys[i]];

              tag_obj[all_pop_keys[i]] = local_value;
            }
          for (var i = 0; i < all_pop_keys.length; i++)
            if (all_pop_keys[i].startsWith("culture-"))
              delete province_obj.pops[all_pop_keys[i]];

          tag_obj = standardisePercentage(tag_obj, province_population, true);
        }

        //Merge province_obj.pops and tag_obj, with overwrite mode
        province_obj.pops = mergeObjects(province_obj.pops, tag_obj, true);
      }

    //Return statement
    return tag_obj;
  }
};
